var St =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/StPageFlip/PageFlip.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/StPageFlip/Style/stPagePlip.css":
/*!***********************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/StPageFlip/Style/stPagePlip.css ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \".stf__parent {\\n  position: relative;\\n  display: block;\\n  box-sizing: border-box;\\n  transform: translateZ(0);\\n}\\n\\n.sft__wrapper {\\n  position: relative;\\n  width: 100%;\\n  box-sizing: border-box;\\n}\\n\\n.stf__parent canvas {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__block {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  perspective: 2000px;\\n}\\n\\n.stf__item {\\n  display: none;\\n  position: absolute;\\n  transform-style: preserve-3d;\\n\\n}\\n\\n.stf__outerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__innerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__hardShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__hardInnerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\", \"\"]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Style/stPagePlip.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack://St/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://St/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./src/StPageFlip/Collection/HTMLPageCollection.ts":
/*!*********************************************************!*\
  !*** ./src/StPageFlip/Collection/HTMLPageCollection.ts ***!
  \*********************************************************/
/*! exports provided: HTMLPageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPageCollection\", function() { return HTMLPageCollection; });\n/* harmony import */ var _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/HTMLPage */ \"./src/StPageFlip/Page/HTMLPage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/StPageFlip/Collection/PageCollection.ts\");\n\n\nclass HTMLPageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\n    constructor(app, render, element, items) {\n        super(app, render);\n        this.element = element;\n        this.pagesElement = items;\n    }\n    load() {\n        for (const pageElement of this.pagesElement) {\n            const page = new _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__[\"HTMLPage\"](this.render, pageElement, pageElement.dataset['density'] === 'hard'\n                ? \"hard\" /* HARD */\n                : \"soft\" /* SOFT */);\n            page.load();\n            this.pages.push(page);\n        }\n        this.createSpread();\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Collection/HTMLPageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Collection/ImagePageCollection.ts":
/*!**********************************************************!*\
  !*** ./src/StPageFlip/Collection/ImagePageCollection.ts ***!
  \**********************************************************/
/*! exports provided: ImagePageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePageCollection\", function() { return ImagePageCollection; });\n/* harmony import */ var _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/ImagePage */ \"./src/StPageFlip/Page/ImagePage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/StPageFlip/Collection/PageCollection.ts\");\n\n\nclass ImagePageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\n    constructor(app, render, imagesHref) {\n        super(app, render);\n        this.imagesHref = imagesHref;\n    }\n    load() {\n        for (const href of this.imagesHref) {\n            const page = new _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__[\"ImagePage\"](this.render, href, \"soft\" /* SOFT */);\n            page.load();\n            this.pages.push(page);\n        }\n        this.createSpread();\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Collection/ImagePageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Collection/PageCollection.ts":
/*!*****************************************************!*\
  !*** ./src/StPageFlip/Collection/PageCollection.ts ***!
  \*****************************************************/
/*! exports provided: PageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageCollection\", function() { return PageCollection; });\nclass PageCollection {\n    constructor(app, render) {\n        this.pages = [];\n        this.currentPageIndex = 0;\n        this.currentSpreadIndex = 0;\n        this.isShowCover = false;\n        this.landscapeSpread = [];\n        this.portraitSpread = [];\n        this.render = render;\n        this.app = app;\n        this.currentPageIndex = 0;\n        this.isShowCover = this.app.getSettings().showCover;\n    }\n    createSpread() {\n        this.landscapeSpread = [];\n        this.portraitSpread = [];\n        for (let i = 0; i < this.pages.length; i++)\n            this.portraitSpread.push([i]);\n        let start = 0;\n        if (this.isShowCover) {\n            this.pages[0].setDensity(\"hard\" /* HARD */);\n            this.landscapeSpread.push([start]);\n            start++;\n        }\n        for (let i = start; i < this.pages.length; i += 2) {\n            if (i < this.pages.length - 1)\n                this.landscapeSpread.push([i, i + 1]);\n            else {\n                this.landscapeSpread.push([i]);\n                this.pages[i].setDensity(\"hard\" /* HARD */);\n            }\n        }\n        console.log(this.landscapeSpread);\n    }\n    getSpread() {\n        return this.render.getOrientation() === \"landscape\" /* LANDSCAPE */\n            ? this.landscapeSpread\n            : this.portraitSpread;\n    }\n    getPageSpreadIndex(pageNum) {\n        const spread = this.getSpread();\n        for (let i = 0; i < spread.length; i++)\n            if ((pageNum === spread[i][0]) || ((spread.length > 1) && (pageNum === spread[i][1])))\n                return i;\n        return null;\n    }\n    getPageCount() {\n        return this.pages.length;\n    }\n    getPages() {\n        return this.pages;\n    }\n    getPage(pageIndex) {\n        if ((pageIndex >= 0) && (pageIndex < this.pages.length)) {\n            return this.pages[pageIndex];\n        }\n        throw new Error('Invalid page number');\n    }\n    nextBy(current) {\n        const idx = this.pages.indexOf(current);\n        if (idx < this.pages.length - 1)\n            return this.pages[idx + 1];\n        return null;\n    }\n    prevBy(current) {\n        const idx = this.pages.indexOf(current);\n        if (idx > 0)\n            return this.pages[idx - 1];\n        return null;\n    }\n    getFlippingPage(direction) {\n        const current = this.currentSpreadIndex;\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\n            return (direction === 0 /* FORWARD */)\n                ? this.pages[current]\n                : this.pages[current - 1];\n        }\n        else {\n            const spread = (direction === 0 /* FORWARD */)\n                ? this.getSpread()[current + 1]\n                : this.getSpread()[current - 1];\n            if (spread.length === 1)\n                return this.pages[spread[0]];\n            return (direction === 0 /* FORWARD */)\n                ? this.pages[spread[0]]\n                : this.pages[spread[1]];\n        }\n    }\n    getBottomPage(direction) {\n        const current = this.currentSpreadIndex;\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\n            return (direction === 0 /* FORWARD */)\n                ? this.pages[current + 1]\n                : this.pages[current - 1];\n        }\n        else {\n            const spread = (direction === 0 /* FORWARD */)\n                ? this.getSpread()[current + 1]\n                : this.getSpread()[current - 1];\n            if (spread.length === 1)\n                return this.pages[spread[0]];\n            return (direction === 0 /* FORWARD */)\n                ? this.pages[spread[1]]\n                : this.pages[spread[0]];\n        }\n    }\n    showNext() {\n        if (this.currentSpreadIndex < this.getSpread().length) {\n            this.currentSpreadIndex++;\n            this.showSpread();\n        }\n    }\n    showPrev() {\n        if (this.currentSpreadIndex > 0) {\n            this.currentSpreadIndex--;\n            this.showSpread();\n        }\n    }\n    getCurrentPageIndex() {\n        return this.currentPageIndex;\n    }\n    show(pageNum = null) {\n        if (pageNum === null)\n            pageNum = this.currentPageIndex;\n        if ((pageNum < 0) || (pageNum >= this.pages.length))\n            return;\n        this.app.updatePageIndex(pageNum);\n        const spreadIndex = this.getPageSpreadIndex(this.currentPageIndex);\n        if (spreadIndex !== null) {\n            this.currentSpreadIndex = spreadIndex;\n            this.showSpread();\n        }\n    }\n    showSpread() {\n        const spread = this.getSpread()[this.currentSpreadIndex];\n        if (spread.length === 2) {\n            this.render.setLeftPage(this.pages[spread[0]]);\n            this.render.setRightPage(this.pages[spread[1]]);\n        }\n        else {\n            if (this.render.getOrientation() === \"landscape\" /* LANDSCAPE */) {\n                if (spread[0] === this.pages.length - 1) {\n                    this.render.setLeftPage(this.pages[spread[0]]);\n                    this.render.setRightPage(null);\n                }\n                else {\n                    this.render.setLeftPage(null);\n                    this.render.setRightPage(this.pages[spread[0]]);\n                }\n            }\n            else {\n                this.render.setLeftPage(null);\n                this.render.setRightPage(this.pages[spread[0]]);\n            }\n        }\n        this.currentPageIndex = spread[0];\n        return spread;\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Collection/PageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Event/EventObject.ts":
/*!*********************************************!*\
  !*** ./src/StPageFlip/Event/EventObject.ts ***!
  \*********************************************/
/*! exports provided: EventObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventObject\", function() { return EventObject; });\nclass EventObject {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, callback) {\n        if (!(eventName in this.events)) {\n            this.events[eventName] = [callback];\n        }\n        else {\n            this.events[eventName].push(callback);\n        }\n        return this;\n    }\n    off(event) {\n        delete this.events[event];\n    }\n    trigger(eventName, app, data = null) {\n        if (eventName in this.events) {\n            this.events[eventName].forEach((callback) => {\n                callback({\n                    data: data,\n                    object: app\n                });\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Event/EventObject.ts?");

/***/ }),

/***/ "./src/StPageFlip/Flip/Flip.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/Flip/Flip.ts ***!
  \*************************************/
/*! exports provided: Flip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Flip\", function() { return Flip; });\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _FlipCalculation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlipCalculation */ \"./src/StPageFlip/Flip/FlipCalculation.ts\");\n\n\nclass Flip {\n    constructor(render, app) {\n        this.flippingPage = null;\n        this.bottomPage = null;\n        this.calc = null;\n        this.state = \"read\" /* READ */;\n        this.render = render;\n        this.app = app;\n    }\n    getCalculation() {\n        return this.calc;\n    }\n    start(globalPos) {\n        this.reset();\n        const bookPos = this.render.convertToBook(globalPos);\n        const rect = this.getBoundsRect();\n        let direction = 0 /* FORWARD */;\n        if (this.render.getOrientation() === \"portrait\" /* PORTRAIT */) {\n            if ((bookPos.x - rect.pageWidth) <= rect.width / 5)\n                direction = 1 /* BACK */;\n        }\n        else if (bookPos.x < rect.width / 2) {\n            direction = 1 /* BACK */;\n        }\n        const flipCorner = (bookPos.y >= rect.height / 2)\n            ? \"bottom\" /* BOTTOM */\n            : \"top\" /* TOP */;\n        if (!this.checkDirection(direction))\n            return false;\n        try {\n            this.flippingPage = this.app.getPageCollection().getFlippingPage(direction);\n            this.bottomPage = this.app.getPageCollection().getBottomPage(direction);\n            if (!this.flippingPage || !this.bottomPage)\n                return false;\n            if (this.render.getOrientation() === \"landscape\" /* LANDSCAPE */) {\n                if (direction === 1 /* BACK */) {\n                    const nextPage = this.app.getPageCollection().nextBy(this.flippingPage);\n                    if (nextPage !== null) {\n                        if (this.flippingPage.getDensity() !== nextPage.getDensity()) {\n                            this.flippingPage.setDrawingDensity(\"hard\" /* HARD */);\n                            nextPage.setDrawingDensity(\"hard\" /* HARD */);\n                        }\n                    }\n                }\n                else {\n                    const prevPage = this.app.getPageCollection().prevBy(this.flippingPage);\n                    if (prevPage !== null) {\n                        if (this.flippingPage.getDensity() !== prevPage.getDensity()) {\n                            this.flippingPage.setDrawingDensity(\"hard\" /* HARD */);\n                            prevPage.setDrawingDensity(\"hard\" /* HARD */);\n                        }\n                    }\n                }\n            }\n            this.render.setDirection(direction);\n            this.calc = new _FlipCalculation__WEBPACK_IMPORTED_MODULE_1__[\"FlipCalculation\"](direction, flipCorner, rect.pageWidth, rect.height);\n            return true;\n        }\n        catch (e) {\n            console.log(e);\n            return false;\n        }\n    }\n    showCorner(globalPos) {\n        if (!this.checkState(\"read\" /* READ */, \"fold_corner\" /* FOLD_CORNER */))\n            return;\n        const rect = this.getBoundsRect();\n        const pageWidth = rect.pageWidth;\n        const operatingDistance = Math.sqrt(Math.pow(pageWidth, 2) + Math.pow(rect.height, 2)) / 5;\n        const bookPos = this.render.convertToBook(globalPos);\n        if (((bookPos.x > 0) && (bookPos.y > 0)) &&\n            ((bookPos.x < rect.width) && (bookPos.y < rect.height)) &&\n            ((bookPos.x < operatingDistance) || (bookPos.x > (rect.width - operatingDistance))) &&\n            ((bookPos.y < operatingDistance) || (bookPos.y > rect.height - operatingDistance))) {\n            if (this.calc === null) {\n                if (!this.start(globalPos))\n                    return;\n                this.setState(\"fold_corner\" /* FOLD_CORNER */);\n                this.calc.calc({ x: pageWidth - 1, y: 1 });\n                const fixedCornerSize = 50;\n                const yStart = (this.calc.getCorner() === \"bottom\" /* BOTTOM */)\n                    ? rect.height - 1\n                    : 1;\n                const yDest = (this.calc.getCorner() === \"bottom\" /* BOTTOM */)\n                    ? rect.height - fixedCornerSize\n                    : fixedCornerSize;\n                this.animateFlippingTo({ x: pageWidth - 1, y: yStart }, { x: pageWidth - fixedCornerSize, y: yDest }, false, false);\n            }\n            else {\n                this.do(this.render.convertToPage(globalPos));\n            }\n        }\n        else {\n            this.setState(\"read\" /* READ */);\n            this.render.finishAnimation();\n            this.stopMove();\n        }\n    }\n    fold(globalPos) {\n        this.setState(\"user_fold\" /* USER_FOLD */);\n        if (this.calc === null)\n            this.start(globalPos);\n        this.do(this.render.convertToPage(globalPos));\n    }\n    flip(globalPos) {\n        if (this.calc !== null)\n            this.render.finishAnimation();\n        if (!this.start(globalPos))\n            return;\n        const rect = this.getBoundsRect();\n        this.setState(\"flipping\" /* FLIPPING */);\n        const topMargins = rect.height / 10;\n        const yStart = (this.calc.getCorner() === \"bottom\" /* BOTTOM */)\n            ? rect.height - topMargins\n            : topMargins;\n        const yDest = (this.calc.getCorner() === \"bottom\" /* BOTTOM */)\n            ? rect.height\n            : 0;\n        this.calc.calc({ x: rect.pageWidth - topMargins, y: yStart });\n        this.animateFlippingTo({ x: rect.pageWidth - topMargins, y: yStart }, { x: -rect.pageWidth, y: yDest }, true);\n    }\n    flipNext(corner) {\n        this.flip({\n            x: this.render.getRect().left + this.render.getRect().pageWidth * 2,\n            y: (corner === \"top\" /* TOP */) ? 1 : this.render.getRect().height - 2\n        });\n    }\n    flipPrev(corner) {\n        this.flip({\n            x: 10,\n            y: (corner === \"top\" /* TOP */) ? 1 : this.render.getRect().height - 2\n        });\n    }\n    stopMove() {\n        if (this.calc === null)\n            return;\n        const pos = this.calc.getPosition();\n        const rect = this.getBoundsRect();\n        const y = this.calc.getCorner() === \"bottom\" /* BOTTOM */\n            ? rect.height\n            : 0;\n        if (pos.x <= 0)\n            this.animateFlippingTo(pos, { x: -rect.pageWidth, y }, true);\n        else\n            this.animateFlippingTo(pos, { x: rect.pageWidth, y }, false);\n    }\n    do(pagePos) {\n        if (this.calc === null)\n            return;\n        this.calc.calc(pagePos);\n        const progress = this.calc.getFlippingProgress();\n        this.bottomPage.setArea(this.calc.getBottomClipArea());\n        this.bottomPage.setPosition(this.calc.getBottomPagePosition());\n        this.bottomPage.setAngle(0);\n        this.bottomPage.setHardAngle(0);\n        this.flippingPage.setArea(this.calc.getFlippingClipArea());\n        this.flippingPage.setPosition(this.calc.getActiveCorner());\n        this.flippingPage.setAngle(this.calc.getAngle());\n        if (this.calc.getDirection() === 0 /* FORWARD */) {\n            this.flippingPage.setHardAngle(90 * (200 - (progress * 2)) / 100);\n        }\n        else {\n            this.flippingPage.setHardAngle(-90 * (200 - (progress * 2)) / 100);\n        }\n        this.render.setPageRect(this.calc.getRect());\n        this.render.setBottomPage(this.bottomPage);\n        this.render.setFlippingPage(this.flippingPage);\n        this.render.drawShadow(this.calc.getShadowStartPoint(), this.calc.getShadowAngle(), progress, this.calc.getDirection(), this.calc.getShadowLength());\n    }\n    animateFlippingTo(start, dest, isTurned, needReset = true) {\n        const points = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetCordsFromTwoPoint(start, dest);\n        const frames = [];\n        for (const p of points)\n            frames.push(() => this.do(p));\n        const duration = this.getAnimationDuration(points.length);\n        this.render.startAnimation(frames, duration, () => {\n            if (!this.calc)\n                return;\n            if (isTurned) {\n                if (this.calc.getDirection() === 1 /* BACK */)\n                    this.app.turnToPrevPage();\n                else\n                    this.app.turnToNextPage();\n            }\n            if (needReset) {\n                this.render.setBottomPage(null);\n                this.render.setFlippingPage(null);\n                this.render.clearShadow();\n                this.state = \"read\" /* READ */;\n                this.reset();\n            }\n        });\n    }\n    getAnimationDuration(size) {\n        const defaultTime = this.app.getSettings().flippingTime;\n        if (size >= 1000)\n            return defaultTime;\n        return (size / 1000) * defaultTime;\n    }\n    checkDirection(direction) {\n        if (direction === 0 /* FORWARD */)\n            return (this.app.getCurrentPageIndex() < (this.app.getPageCount() - 1));\n        return (this.app.getCurrentPageIndex() >= 1);\n    }\n    reset() {\n        this.calc = null;\n        this.flippingPage = null;\n        this.bottomPage = null;\n    }\n    getBoundsRect() {\n        return this.render.getRect();\n    }\n    setState(newState) {\n        this.app.updateState(newState);\n        this.state = newState;\n    }\n    checkState(...states) {\n        for (const state of states)\n            if (this.state === state)\n                return true;\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Flip/Flip.ts?");

/***/ }),

/***/ "./src/StPageFlip/Flip/FlipCalculation.ts":
/*!************************************************!*\
  !*** ./src/StPageFlip/Flip/FlipCalculation.ts ***!
  \************************************************/
/*! exports provided: FlipCalculation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlipCalculation\", function() { return FlipCalculation; });\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n\nclass FlipCalculation {\n    constructor(direction, corner, pageWidth, pageHeight) {\n        this.direction = direction;\n        this.corner = corner;\n        this.pageWidth = pageWidth;\n        this.pageHeight = pageHeight;\n        this.topIntersectPoint = null;\n        this.sideIntersectPoint = null;\n        this.bottomIntersectPoint = null;\n    }\n    calc(localPos) {\n        try {\n            this.position = this.preparePosition(localPos);\n            this.calculateIntersectPoint(this.position);\n        }\n        catch (e) {\n            //console.log(e);\n        }\n    }\n    getPageRect(localPos) {\n        if (this.corner === \"top\" /* TOP */) {\n            return this.getRectFromBasePoint([\n                { x: 0, y: 0 },\n                { x: this.pageWidth, y: 0 },\n                { x: 0, y: this.pageHeight },\n                { x: this.pageWidth, y: this.pageHeight }\n            ], localPos);\n        }\n        return this.getRectFromBasePoint([\n            { x: 0, y: -this.pageHeight },\n            { x: this.pageWidth, y: -this.pageHeight },\n            { x: 0, y: 0 },\n            { x: this.pageWidth, y: 0 }\n        ], localPos);\n    }\n    getRectFromBasePoint(points, localPos) {\n        return {\n            topLeft: this.getRotatedPoint(points[0], localPos),\n            topRight: this.getRotatedPoint(points[1], localPos),\n            bottomLeft: this.getRotatedPoint(points[2], localPos),\n            bottomRight: this.getRotatedPoint(points[3], localPos)\n        };\n    }\n    getRotatedPoint(transformedPoint, startPoint) {\n        return {\n            x: transformedPoint.x * Math.cos(this.angle) + transformedPoint.y * Math.sin(this.angle) + startPoint.x,\n            y: transformedPoint.y * Math.cos(this.angle) - transformedPoint.x * Math.sin(this.angle) + startPoint.y\n        };\n    }\n    updateAngleAndGeometry(pos) {\n        this.angle = this.calculateAngle(pos);\n        this.rect = this.getPageRect(pos);\n    }\n    calculateIntersectPoint(pos) {\n        const boundRect = {\n            left: -1,\n            top: -1,\n            width: this.pageWidth + 2,\n            height: this.pageHeight + 2\n        };\n        if (this.corner === \"top\" /* TOP */) {\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.topRight], [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.bottomLeft], [{ x: this.pageWidth, y: 0 }, { x: this.pageWidth, y: this.pageHeight }]);\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [{ x: 0, y: this.pageHeight }, { x: this.pageWidth, y: this.pageHeight }]);\n        }\n        else {\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.topLeft, this.rect.topRight], [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.topLeft], [{ x: this.pageWidth, y: 0 }, { x: this.pageWidth, y: this.pageHeight }]);\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [{ x: 0, y: this.pageHeight }, { x: this.pageWidth, y: this.pageHeight }]);\n        }\n    }\n    checkPositionAtCenterLine(checkedPos, centerOne, centerTwo) {\n        let result = checkedPos;\n        const tmp = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByLineAndCircle(centerOne, this.pageWidth, result);\n        if (result !== tmp) {\n            result = tmp;\n            this.updateAngleAndGeometry(result);\n        }\n        const rad = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\n        let checkPointOne = this.rect.bottomRight;\n        let checkPointTwo = this.rect.topLeft;\n        if (this.corner === \"bottom\" /* BOTTOM */) {\n            checkPointOne = this.rect.topRight;\n            checkPointTwo = this.rect.bottomLeft;\n        }\n        if (checkPointOne.x <= 0) {\n            const bottomPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByLineAndCircle(centerTwo, rad, checkPointTwo);\n            if (bottomPoint !== result) {\n                result = bottomPoint;\n                this.updateAngleAndGeometry(result);\n            }\n        }\n        return result;\n    }\n    preparePosition(pos) {\n        let result = pos;\n        this.updateAngleAndGeometry(result);\n        if (this.corner === \"top\" /* TOP */) {\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: 0 }, { x: 0, y: this.pageHeight });\n        }\n        else {\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: this.pageHeight }, { x: 0, y: 0 });\n        }\n        if ((Math.abs(result.x - this.pageWidth) < 1) && (Math.abs(result.y) < 1)) {\n            throw new Error('Point is too small');\n        }\n        return result;\n    }\n    calculateAngle(pos) {\n        const left = this.pageWidth - pos.x;\n        const top = (this.corner === \"bottom\" /* BOTTOM */)\n            ? this.pageHeight - pos.y\n            : pos.y;\n        let angle = 2 * Math.acos(left / Math.sqrt(top * top + left * left));\n        if (top < 0)\n            angle = -angle;\n        const da = Math.PI - angle;\n        if (!isFinite(angle) || ((da >= 0) && (da < 0.003)))\n            throw new Error('The G point is too small');\n        if (this.corner === \"bottom\" /* BOTTOM */)\n            angle = -angle;\n        return angle;\n    }\n    getAngle() {\n        if (this.direction === 0 /* FORWARD */) {\n            return -this.angle;\n        }\n        return this.angle;\n    }\n    getRect() {\n        return this.rect;\n    }\n    getPosition() {\n        return this.position;\n    }\n    getActiveCorner() {\n        if (this.direction === 0 /* FORWARD */) {\n            return this.rect.topLeft;\n        }\n        return this.rect.topRight;\n    }\n    getDirection() {\n        return this.direction;\n    }\n    getIntersectPoint() {\n        return {\n            top: this.topIntersectPoint,\n            bottom: this.bottomIntersectPoint,\n            side: this.sideIntersectPoint\n        };\n    }\n    getSegmentToShadowLine() {\n        const first = this.getShadowStartPoint();\n        const second = ((first !== this.sideIntersectPoint) && (this.sideIntersectPoint !== null))\n            ? this.sideIntersectPoint\n            : this.bottomIntersectPoint;\n        return [first, second];\n    }\n    getShadowStartPoint() {\n        if (this.corner === \"top\" /* TOP */) {\n            return this.topIntersectPoint;\n        }\n        else {\n            if (this.sideIntersectPoint !== null)\n                return this.sideIntersectPoint;\n            return this.topIntersectPoint;\n        }\n    }\n    getShadowAngle() {\n        const angle = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetAngleFromTwoLine(this.getSegmentToShadowLine(), [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n        if (this.direction === 0 /* FORWARD */) {\n            return angle;\n        }\n        return Math.PI - angle;\n    }\n    getShadowLength() {\n        return _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetSegmentLength(this.getSegmentToShadowLine());\n    }\n    getFlippingProgress() {\n        return Math.abs((this.position.x - this.pageWidth) / (2 * this.pageWidth) * 100);\n    }\n    getFlippingClipArea() {\n        const result = [];\n        let clipBottom = false;\n        result.push(this.rect.topLeft);\n        result.push(this.topIntersectPoint);\n        if (this.sideIntersectPoint === null) {\n            clipBottom = true;\n        }\n        else {\n            result.push(this.sideIntersectPoint);\n            if (this.bottomIntersectPoint === null)\n                clipBottom = false;\n        }\n        result.push(this.bottomIntersectPoint);\n        if ((clipBottom) || (this.corner === \"bottom\" /* BOTTOM */)) {\n            result.push(this.rect.bottomLeft);\n        }\n        return result;\n    }\n    getCorner() {\n        return this.corner;\n    }\n    getBottomClipArea() {\n        const result = [];\n        result.push(this.topIntersectPoint);\n        if (this.corner === \"top\" /* TOP */) {\n            result.push({ x: this.pageWidth, y: 0 });\n        }\n        else {\n            if (this.topIntersectPoint !== null) {\n                result.push({ x: this.pageWidth, y: 0 });\n            }\n            result.push({ x: this.pageWidth, y: this.pageHeight });\n        }\n        if (this.sideIntersectPoint !== null) {\n            if (_Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetDestinationFromTwoPoint(this.sideIntersectPoint, this.topIntersectPoint) >= 10)\n                result.push(this.sideIntersectPoint);\n        }\n        else {\n            if (this.corner === \"top\" /* TOP */) {\n                result.push({ x: this.pageWidth, y: this.pageHeight });\n            }\n        }\n        result.push(this.bottomIntersectPoint);\n        result.push(this.topIntersectPoint);\n        return result;\n    }\n    getBottomPagePosition() {\n        if (this.direction === 1 /* BACK */) {\n            return { x: this.pageWidth, y: 0 };\n        }\n        return { x: 0, y: 0 };\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Flip/FlipCalculation.ts?");

/***/ }),

/***/ "./src/StPageFlip/Helper.ts":
/*!**********************************!*\
  !*** ./src/StPageFlip/Helper.ts ***!
  \**********************************/
/*! exports provided: Helper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Helper\", function() { return Helper; });\nclass Helper {\n    static GetDestinationFromTwoPoint(point1, point2) {\n        if ((point1 === null) || (point2 === null)) {\n            return Infinity;\n        }\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n    }\n    static GetSegmentLength(line) {\n        return Helper.GetDestinationFromTwoPoint(line[0], line[1]);\n    }\n    static GetAngleFromTwoLine(line1, line2) {\n        const A1 = line1[0].y - line1[1].y;\n        const A2 = line2[0].y - line2[1].y;\n        const B1 = line1[1].x - line1[0].x;\n        const B2 = line2[1].x - line2[0].x;\n        return Math.acos((A1 * A2 + B1 * B2) / (Math.sqrt(A1 * A1 + B1 * B1) * Math.sqrt(A2 * A2 + B2 * B2)));\n    }\n    static PointInRect(rect, pos) {\n        if (pos === null) {\n            return null;\n        }\n        if ((pos.x >= rect.left) && (pos.x <= rect.width + rect.left) &&\n            (pos.y >= rect.top) && (pos.y <= rect.top + rect.height)) {\n            return pos;\n        }\n        return null;\n    }\n    static GetRotatedPoint(transformedPoint, startPoint, angle) {\n        return {\n            x: transformedPoint.x * Math.cos(angle) + transformedPoint.y * Math.sin(angle) + startPoint.x,\n            y: transformedPoint.y * Math.cos(angle) - transformedPoint.x * Math.sin(angle) + startPoint.y\n        };\n    }\n    static GetIntersectByLineAndCircle(startPoint, radius, linePoint) {\n        if (Helper.GetDestinationFromTwoPoint(startPoint, linePoint) <= radius) {\n            return linePoint;\n        }\n        const a = startPoint.x;\n        const b = startPoint.y;\n        const n = linePoint.x;\n        const m = linePoint.y;\n        let x = Math.sqrt((Math.pow(radius, 2) * Math.pow(a - n, 2)) / (Math.pow(a - n, 2) + Math.pow(b - m, 2))) + a;\n        if (linePoint.x < 0) {\n            x *= -1;\n        }\n        let y = ((x - a) * (b - m)) / (a - n) + b;\n        if (((a - n) + b) === 0) {\n            y = radius;\n        }\n        return {\n            x,\n            y\n        };\n    }\n    static GetIntersectByTwoSegment(rectBorder, one, two) {\n        return Helper.PointInRect(rectBorder, Helper.GetIntersectByTwoLine(one, two));\n    }\n    static GetIntersectByTwoLine(one, two) {\n        const A1 = one[0].y - one[1].y;\n        const A2 = two[0].y - two[1].y;\n        const B1 = one[1].x - one[0].x;\n        const B2 = two[1].x - two[0].x;\n        const C1 = one[0].x * one[1].y - one[1].x * one[0].y;\n        const C2 = two[0].x * two[1].y - two[1].x * two[0].y;\n        const det1 = A1 * C2 - A2 * C1;\n        const det2 = B1 * C2 - B2 * C1;\n        const x = -((C1 * B2 - C2 * B1) / (A1 * B2 - A2 * B1));\n        const y = -((A1 * C2 - A2 * C1) / (A1 * B2 - A2 * B1));\n        if (isFinite(x) && isFinite(y)) {\n            return { x, y };\n        }\n        else {\n            if (Math.abs(det1 - det2) < 0.1)\n                throw new Error('Segment included');\n        }\n        return null;\n    }\n    static GetCordsFromTwoPoint(pointOne, pointTwo) {\n        const sizeX = Math.abs(pointOne.x - pointTwo.x);\n        const sizeY = Math.abs(pointOne.y - pointTwo.y);\n        const lengthLine = Math.max(sizeX, sizeY);\n        const result = [pointOne];\n        function getCord(c1, c2, size, length, index) {\n            if (c2 > c1) {\n                return c1 + (index * (size / length));\n            }\n            else if (c2 < c1) {\n                return c1 - (index * (size / length));\n            }\n            return c1;\n        }\n        for (let i = 1; i <= lengthLine; i++) {\n            result.push({\n                x: getCord(pointOne.x, pointTwo.x, sizeX, lengthLine, i),\n                y: getCord(pointOne.y, pointTwo.y, sizeY, lengthLine, i)\n            });\n        }\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Helper.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/HTMLPage.ts":
/*!*****************************************!*\
  !*** ./src/StPageFlip/Page/HTMLPage.ts ***!
  \*****************************************/
/*! exports provided: HTMLPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPage\", function() { return HTMLPage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/StPageFlip/Page/Page.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n\n\nclass HTMLPage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\n    constructor(render, element, density) {\n        super(render, density);\n        this.copiedElement = null;\n        this.isLoad = false;\n        this.element = element;\n        this.element.classList.add('stf__item');\n        this.element.classList.add('--' + density);\n    }\n    draw(tempDensity) {\n        const density = tempDensity ? tempDensity : this.nowDrawingDensity;\n        const pagePos = this.render.convertToGlobal(this.state.position);\n        const pageWidth = this.render.getRect().pageWidth;\n        const pageHeight = this.render.getRect().height;\n        this.element.classList.remove('--simple');\n        this.element.style.display = \"block\";\n        this.element.style.left = \"0\";\n        this.element.style.top = \"0\";\n        this.element.style.width = pageWidth + \"px\";\n        this.element.style.height = pageHeight + \"px\";\n        if (density === \"hard\" /* HARD */)\n            this.drawHard();\n        else\n            this.drawSoft(pagePos);\n    }\n    drawHard() {\n        const pos = this.render.getRect().left + this.render.getRect().width / 2;\n        this.element.style.backfaceVisibility = 'hidden';\n        this.element.style.setProperty('-webkit-backface-visibility', \"hidden\");\n        const angle = this.state.hardDrawingAngle;\n        if (this.orientation === 0 /* LEFT */) {\n            this.element.style.transformOrigin = this.render.getRect().pageWidth + 'px 0';\n            this.element.style.transform = \"translate3d(\" + 0 + \"px, \" + 0 + \"px, 0) rotateY(\" + angle + \"deg)\";\n        }\n        else {\n            this.element.style.transformOrigin = \"0 0\";\n            this.element.style.transform = \"translate3d(\" + pos + \"px, \" + 0 + \"px, 0) rotateY(\" + angle + \"deg)\";\n        }\n        this.element.style.clipPath = \"none\";\n        this.element.style.setProperty('-webkit-clip-path', \"none\");\n    }\n    drawSoft(position) {\n        this.element.style.transformOrigin = \"0 0\";\n        let polygon = 'polygon( ';\n        for (const p of this.state.area) {\n            if (p !== null) {\n                let g = (this.render.getDirection() === 1 /* BACK */)\n                    ? {\n                        x: -p.x + this.state.position.x,\n                        y: p.y - this.state.position.y\n                    }\n                    : {\n                        x: p.x - this.state.position.x,\n                        y: p.y - this.state.position.y\n                    };\n                g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: 0, y: 0 }, this.state.angle);\n                polygon += g.x + 'px ' + g.y + 'px, ';\n            }\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.element.style.clipPath = polygon;\n        this.element.style.setProperty('-webkit-clip-path', polygon);\n        this.element.style.transform = \"translate3d(\" + position.x + \"px, \" + position.y + \"px, 0) rotate(\" + this.state.angle + \"rad)\";\n    }\n    simpleDraw(orient) {\n        if (this.element.classList.contains('--simple'))\n            return;\n        if (this.copiedElement === null) {\n            this.copiedElement = this.element.cloneNode(true);\n            this.element.parentElement.appendChild(this.copiedElement);\n        }\n        const rect = this.render.getRect();\n        const pageWidth = rect.pageWidth;\n        const pageHeight = rect.height;\n        const x = (orient === 1 /* RIGHT */)\n            ? rect.left + rect.pageWidth\n            : rect.left;\n        const y = rect.top;\n        this.element.classList.add('--simple');\n        this.copiedElement.style.cssText = \"position: absolute; display: block; height: \" + pageHeight + \"px; left: \" +\n            x + \"px; top: \" + y + \"px; width: \" + pageWidth + \"px; z-index: \" + (this.render.getSettings().startZIndex + 1) + \";\";\n        this.element.style.cssText = \"display: none\";\n    }\n    clearSaved() {\n        this.element.classList.remove('--simple');\n        if (this.copiedElement !== null) {\n            this.copiedElement.remove();\n            this.copiedElement = null;\n        }\n    }\n    getElement() {\n        return this.element;\n    }\n    load() {\n        this.isLoad = true;\n    }\n    setOrientation(orientation) {\n        super.setOrientation(orientation);\n        this.element.classList.remove('--left', '--right');\n        this.element.classList.add((orientation === 1 /* RIGHT */)\n            ? '--right'\n            : '--left');\n    }\n    setDrawingDensity(density) {\n        this.element.classList.remove('--soft', '--hard');\n        this.element.classList.add('--' + density);\n        super.setDrawingDensity(density);\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Page/HTMLPage.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/ImagePage.ts":
/*!******************************************!*\
  !*** ./src/StPageFlip/Page/ImagePage.ts ***!
  \******************************************/
/*! exports provided: ImagePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePage\", function() { return ImagePage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/StPageFlip/Page/Page.ts\");\n\nclass ImagePage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\n    constructor(render, href, density) {\n        super(render, density);\n        this.image = null;\n        this.isLoad = false;\n        this.loadingAngle = 0;\n        this.image = new Image();\n        this.image.src = href;\n    }\n    draw(tempDensity) {\n        const ctx = this.render.getContext();\n        const pagePos = this.render.convertToGlobal(this.state.position);\n        const pageWidth = this.render.getRect().pageWidth;\n        const pageHeight = this.render.getRect().height;\n        ctx.save();\n        ctx.translate(pagePos.x, pagePos.y);\n        ctx.beginPath();\n        for (let p of this.state.area) {\n            if (p !== null) {\n                p = this.render.convertToGlobal(p);\n                ctx.lineTo(p.x - pagePos.x, p.y - pagePos.y);\n            }\n        }\n        ctx.rotate(this.state.angle);\n        ctx.clip();\n        //ctx.imageSmoothingQuality = 'high';\n        if (!this.isLoad) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgb(200, 200, 200)';\n            ctx.fillStyle = 'rgb(255, 255, 255)';\n            ctx.lineWidth = 1;\n            ctx.rect(1, 1, pageWidth - 1, pageHeight - 1);\n            ctx.stroke();\n            ctx.fill();\n            const middlePoint = {\n                x: pageWidth / 2,\n                y: pageHeight / 2\n            };\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.arc(middlePoint.x, middlePoint.y, 20, this.loadingAngle, 3 * Math.PI / 2 + this.loadingAngle);\n            ctx.stroke();\n            ctx.closePath();\n            this.loadingAngle += 0.07;\n            if (this.loadingAngle >= 2 * Math.PI) {\n                this.loadingAngle = 0;\n            }\n        }\n        else {\n            ctx.drawImage(this.image, 0, 0, pageWidth, pageHeight);\n        }\n        ctx.restore();\n    }\n    simpleDraw(orient) {\n        const rect = this.render.getRect();\n        const ctx = this.render.getContext();\n        const pageWidth = rect.pageWidth;\n        const pageHeight = rect.height;\n        const x = (orient === 1 /* RIGHT */)\n            ? rect.left + rect.pageWidth\n            : rect.left;\n        const y = rect.top;\n        if (!this.isLoad) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgb(200, 200, 200)';\n            ctx.fillStyle = 'rgb(255, 255, 255)';\n            ctx.lineWidth = 1;\n            ctx.rect(x + 1, y + 1, pageWidth - 1, pageHeight - 1);\n            ctx.stroke();\n            ctx.fill();\n            const middlePoint = {\n                x: x + pageWidth / 2,\n                y: y + pageHeight / 2\n            };\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.arc(middlePoint.x, middlePoint.y, 20, this.loadingAngle, 3 * Math.PI / 2 + this.loadingAngle);\n            ctx.stroke();\n            ctx.closePath();\n            this.loadingAngle += 0.07;\n            if (this.loadingAngle >= 2 * Math.PI) {\n                this.loadingAngle = 0;\n            }\n        }\n        else {\n            ctx.drawImage(this.image, x, y, pageWidth, pageHeight);\n        }\n    }\n    load() {\n        if (!this.isLoad)\n            this.image.onload = () => {\n                this.isLoad = true;\n            };\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Page/ImagePage.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/Page.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/Page/Page.ts ***!
  \*************************************/
/*! exports provided: Page */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Page\", function() { return Page; });\nclass Page {\n    constructor(render, density) {\n        this.state = {\n            angle: 0,\n            area: [],\n            corners: null,\n            position: { x: 0, y: 0 },\n            hardAngle: 0,\n            hardDrawingAngle: 0\n        };\n        this.createdDensity = density;\n        this.nowDrawingDensity = this.createdDensity;\n        this.render = render;\n    }\n    setDensity(density) {\n        this.createdDensity = density;\n        this.nowDrawingDensity = density;\n    }\n    setDrawingDensity(density) {\n        this.nowDrawingDensity = density;\n    }\n    getDrawingDensity() {\n        return this.nowDrawingDensity;\n    }\n    getDensity() {\n        return this.createdDensity;\n    }\n    setPosition(pagePos) {\n        this.state.position = pagePos;\n    }\n    setAngle(angle) {\n        this.state.angle = angle;\n    }\n    setArea(area) {\n        this.state.area = area;\n    }\n    setCorners(corners) {\n        this.state.corners = corners;\n    }\n    getAngle() {\n        return this.state.angle;\n    }\n    setHardAngle(angle) {\n        this.state.hardAngle = angle;\n        this.state.hardDrawingAngle = angle;\n    }\n    setHardDrawingAngle(angle) {\n        this.state.hardDrawingAngle = angle;\n    }\n    getHardAngle() {\n        return this.state.hardAngle;\n    }\n    setOrientation(orientation) {\n        this.orientation = orientation;\n    }\n    getOrientation() {\n        return this.orientation;\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Page/Page.ts?");

/***/ }),

/***/ "./src/StPageFlip/PageFlip.ts":
/*!************************************!*\
  !*** ./src/StPageFlip/PageFlip.ts ***!
  \************************************/
/*! exports provided: PageFlip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageFlip\", function() { return PageFlip; });\n/* harmony import */ var _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection/ImagePageCollection */ \"./src/StPageFlip/Collection/ImagePageCollection.ts\");\n/* harmony import */ var _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection/HTMLPageCollection */ \"./src/StPageFlip/Collection/HTMLPageCollection.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n/* harmony import */ var _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Render/CanvasRender */ \"./src/StPageFlip/Render/CanvasRender.ts\");\n/* harmony import */ var _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UI/HTMLUI */ \"./src/StPageFlip/UI/HTMLUI.ts\");\n/* harmony import */ var _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UI/CanvasUI */ \"./src/StPageFlip/UI/CanvasUI.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Event/EventObject */ \"./src/StPageFlip/Event/EventObject.ts\");\n/* harmony import */ var _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Render/HTMLRender */ \"./src/StPageFlip/Render/HTMLRender.ts\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Settings */ \"./src/StPageFlip/Settings.ts\");\n/* harmony import */ var _Style_stPagePlip_css__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Style/stPagePlip.css */ \"./src/StPageFlip/Style/stPagePlip.css\");\n/* harmony import */ var _Style_stPagePlip_css__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_Style_stPagePlip_css__WEBPACK_IMPORTED_MODULE_10__);\n\n\n\n\n\n\n\n\n\n\n\nclass PageFlip extends _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__[\"EventObject\"] {\n    constructor(inBlock, setting) {\n        super();\n        this.isUserTouch = false;\n        this.isUserMove = false;\n        this.pages = null;\n        //private currentPage = 0;\n        this.setting = null;\n        try {\n            this.setting = (new _Settings__WEBPACK_IMPORTED_MODULE_9__[\"Settings\"]()).getSettings(setting);\n            this.block = inBlock;\n        }\n        catch (e) {\n            //\n        }\n    }\n    update() {\n        this.render.update();\n        this.pages.show();\n    }\n    turnToPrevPage() {\n        this.pages.showPrev();\n    }\n    turnToNextPage() {\n        this.pages.showNext();\n    }\n    turnToPage(pageNum) {\n        this.pages.show(pageNum);\n    }\n    flipNext(corner = \"top\" /* TOP */) {\n        this.flip.flipNext(corner);\n    }\n    flipPrev(corner = \"top\" /* TOP */) {\n        this.flip.flipPrev(corner);\n    }\n    loadFromImages(imagesHref) {\n        this.ui = new _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__[\"CanvasUI\"](this.block, this, this.setting);\n        const canvas = this.ui.getCanvas();\n        this.render = new _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__[\"CanvasRender\"](this, this.setting, canvas);\n        this.flip = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\n        this.pages = new _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__[\"ImagePageCollection\"](this, this.render, imagesHref);\n        this.pages.load();\n        this.render.start();\n        this.pages.show(this.setting.startPage);\n    }\n    loadFromHTML(items) {\n        this.ui = new _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__[\"HTMLUI\"](this.block, this, this.setting, items);\n        this.render = new _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_8__[\"HTMLRender\"](this, this.setting, this.ui.getDistElement(), items);\n        this.flip = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\n        this.pages = new _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__[\"HTMLPageCollection\"](this, this.render, this.ui.getDistElement(), items);\n        this.pages.load();\n        this.render.start();\n        this.pages.show(this.setting.startPage);\n    }\n    updateState(newState) {\n        this.trigger('changeState', this, newState);\n    }\n    updatePageIndex(newPage) {\n        this.trigger('flip', this, newPage);\n    }\n    updateOrientation(newOrientation) {\n        this.update();\n        this.ui.setOrientationStyle(newOrientation);\n        this.trigger('changeOrientation', this, newOrientation);\n    }\n    getPageCount() {\n        return this.pages.getPageCount();\n    }\n    getCurrentPageIndex() {\n        return this.pages.getCurrentPageIndex();\n    }\n    getPage(pageNum) {\n        return this.pages.getPage(pageNum);\n    }\n    getRender() {\n        return this.render;\n    }\n    getFlipObject() {\n        return this.flip;\n    }\n    getOrientation() {\n        return this.render.getOrientation();\n    }\n    getBoundsRect() {\n        return this.render.getRect();\n    }\n    getSettings() {\n        return this.setting;\n    }\n    getUI() {\n        return this.ui;\n    }\n    getPageCollection() {\n        return this.pages;\n    }\n    startUserTouch(pos) {\n        this.mousePosition = pos;\n        this.isUserTouch = true;\n        this.isUserMove = false;\n    }\n    userMove(pos, isTouch) {\n        if ((!this.isUserTouch) && (!isTouch)) {\n            this.flip.showCorner(pos);\n        }\n        else if (this.isUserTouch) {\n            if (_Helper__WEBPACK_IMPORTED_MODULE_6__[\"Helper\"].GetDestinationFromTwoPoint(this.mousePosition, pos) > 5) {\n                this.isUserMove = true;\n                this.flip.fold(pos);\n            }\n        }\n    }\n    userStop(pos, isSwipe = false) {\n        if (this.isUserTouch) {\n            this.isUserTouch = false;\n            if (!isSwipe) {\n                if (!this.isUserMove)\n                    this.flip.flip(pos);\n                else\n                    this.flip.stopMove();\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/PageFlip.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/CanvasRender.ts":
/*!***********************************************!*\
  !*** ./src/StPageFlip/Render/CanvasRender.ts ***!
  \***********************************************/
/*! exports provided: CanvasRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRender\", function() { return CanvasRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/StPageFlip/Render/Render.ts\");\n\nclass CanvasRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\n    constructor(app, setting, inCanvas) {\n        super(app, setting);\n        this.canvas = inCanvas;\n        this.ctx = inCanvas.getContext('2d');\n    }\n    getBlockWidth() {\n        return this.canvas.offsetWidth;\n    }\n    getBlockHeight() {\n        return this.canvas.offsetHeight;\n    }\n    getContext() {\n        return this.ctx;\n    }\n    drawFrame(timer) {\n        this.clear();\n        if (this.orientation !== \"portrait\" /* PORTRAIT */)\n            if (this.leftPage != null)\n                this.leftPage.simpleDraw(0 /* LEFT */);\n        if (this.rightPage != null)\n            this.rightPage.simpleDraw(1 /* RIGHT */);\n        if (this.bottomPage != null)\n            this.bottomPage.draw();\n        this.drawBookShadow();\n        if (this.flippingPage != null)\n            this.flippingPage.draw();\n        if (this.shadow != null) {\n            this.drawOuterShadow();\n            this.drawInnerShadow();\n        }\n        const rect = this.getRect();\n        if (this.orientation === \"portrait\" /* PORTRAIT */) {\n            this.ctx.beginPath();\n            this.ctx.rect(rect.left + rect.pageWidth, rect.top, rect.width, rect.height);\n            this.ctx.clip();\n        }\n    }\n    drawBookShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        const shadowSize = rect.width / 20;\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n        const shadowPos = { x: (rect.left + rect.width / 2) - shadowSize / 2, y: 0 };\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        const outerGradient = this.ctx.createLinearGradient(0, 0, shadowSize, 0);\n        outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        outerGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.2)');\n        outerGradient.addColorStop(0.49, 'rgba(0, 0, 0, 0.1)');\n        outerGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');\n        outerGradient.addColorStop(0.51, 'rgba(0, 0, 0, 0.4)');\n        outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        this.ctx.clip();\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, shadowSize, rect.height * 2);\n        this.ctx.restore();\n    }\n    drawOuterShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n        const outerGradient = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\n        if (this.shadow.direction === 0 /* FORWARD */) {\n            this.ctx.translate(0, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        }\n        else {\n            this.ctx.translate(-this.shadow.width, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n        }\n        this.ctx.clip();\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, this.shadow.width, rect.height * 2);\n        this.ctx.restore();\n    }\n    drawInnerShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        const pageRect = this.convertRectToGlobal(this.pageRect);\n        this.ctx.moveTo(pageRect.topLeft.x, pageRect.topLeft.y);\n        this.ctx.lineTo(pageRect.topRight.x, pageRect.topRight.y);\n        this.ctx.lineTo(pageRect.bottomRight.x, pageRect.bottomRight.y);\n        this.ctx.lineTo(pageRect.bottomLeft.x, pageRect.bottomLeft.y);\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n        const isw = this.shadow.width * 3 / 4;\n        const innerGradient = this.ctx.createLinearGradient(0, 0, isw, 0);\n        if (this.shadow.direction === 0 /* FORWARD */) {\n            this.ctx.translate(-isw, -100);\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.7, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        }\n        else {\n            this.ctx.translate(0, -100);\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.3, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        }\n        this.ctx.clip();\n        this.ctx.fillStyle = innerGradient;\n        this.ctx.fillRect(0, 0, isw, rect.height * 2);\n        this.ctx.restore();\n    }\n    clear() {\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Render/CanvasRender.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/HTMLRender.ts":
/*!*********************************************!*\
  !*** ./src/StPageFlip/Render/HTMLRender.ts ***!
  \*********************************************/
/*! exports provided: HTMLRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLRender\", function() { return HTMLRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/StPageFlip/Render/Render.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n\n\nclass HTMLRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\n    constructor(app, setting, element, items) {\n        super(app, setting);\n        this.outerShadow = null;\n        this.innerShadow = null;\n        this.hardShadow = null;\n        this.hardInnerShadow = null;\n        this.element = element;\n        this.items = items;\n    }\n    getBlockWidth() {\n        return this.element.offsetWidth;\n    }\n    getBlockHeight() {\n        return this.element.offsetHeight;\n    }\n    clearShadow() {\n        super.clearShadow();\n        this.outerShadow.remove();\n        this.innerShadow.remove();\n        this.hardShadow.remove();\n        this.hardInnerShadow.remove();\n        this.outerShadow = null;\n        this.innerShadow = null;\n        this.hardShadow = null;\n        this.hardInnerShadow = null;\n    }\n    drawShadow(pos, angle, t, direction, length) {\n        super.drawShadow(pos, angle, t, direction, length);\n        if (this.outerShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__outerShadow\"></div>');\n            this.outerShadow = this.element.querySelector('.stf__outerShadow');\n            this.outerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\n        }\n        if (this.innerShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__innerShadow\"></div>');\n            this.innerShadow = this.element.querySelector('.stf__innerShadow');\n            this.innerShadow.style.zIndex = (this.getSettings().startZIndex + 10).toString(10);\n        }\n        if (this.hardShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__hardShadow\"></div>');\n            this.hardShadow = this.element.querySelector('.stf__hardShadow');\n            this.hardShadow.style.zIndex = (this.getSettings().startZIndex + 3).toString(10);\n        }\n        if (this.hardShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__hardShadow\"></div>');\n            this.hardShadow = this.element.querySelector('.stf__hardShadow');\n            this.hardShadow.style.zIndex = (this.getSettings().startZIndex + 3).toString(10);\n        }\n        if (this.hardInnerShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__hardInnerShadow\"></div>');\n            this.hardInnerShadow = this.element.querySelector('.stf__hardInnerShadow');\n            this.hardInnerShadow.style.zIndex = (this.getSettings().startZIndex + 3).toString(10);\n        }\n    }\n    drawHardInnerShadow() {\n        const rect = this.getRect();\n        const progress = this.shadow.progress > 100\n            ? 200 - this.shadow.progress\n            : this.shadow.progress;\n        let innerShadowSize = ((100 - progress) * (3 * rect.pageWidth) / 100) + 20;\n        if (innerShadowSize > rect.pageWidth)\n            innerShadowSize = rect.pageWidth;\n        this.hardInnerShadow.style.width = innerShadowSize + 'px';\n        this.hardInnerShadow.style.height = rect.height + 'px';\n        this.hardInnerShadow.style.background = \"linear-gradient(to right, \" +\n            \"rgba(0, 0, 0, \" + (this.shadow.opacity * progress / 100) + \") 5%, \" +\n            \"rgba(0, 0, 0, 0) 100% \" +\n            \")\";\n        this.hardInnerShadow.style.left = rect.left + rect.width / 2 + 'px';\n        this.hardInnerShadow.style.transformOrigin = \"0 0\";\n        this.hardInnerShadow.style.transform =\n            (((this.getDirection() === 0 /* FORWARD */) && (this.shadow.progress > 100)) ||\n                ((this.getDirection() === 1 /* BACK */) && (this.shadow.progress <= 100)))\n                ? this.hardInnerShadow.style.transform = 'translate3d(0, 0, 0)'\n                : this.hardInnerShadow.style.transform = 'translate3d(0, 0, 0) rotateY(180deg)';\n    }\n    drawHardOuterShadow() {\n        const rect = this.getRect();\n        const progress = this.shadow.progress > 100\n            ? 200 - this.shadow.progress\n            : this.shadow.progress;\n        let innerShadowSize = ((100 - progress) * (3 * rect.pageWidth) / 100) + 20;\n        if (innerShadowSize > rect.pageWidth)\n            innerShadowSize = rect.pageWidth;\n        this.hardShadow.style.width = innerShadowSize + 'px';\n        this.hardShadow.style.height = rect.height + 'px';\n        this.hardShadow.style.background = \"linear-gradient(to left, \" +\n            \"rgba(0, 0, 0, \" + this.shadow.opacity + \") 5%, \" +\n            \"rgba(0, 0, 0, 0) 100% \" +\n            \")\";\n        this.hardShadow.style.left = rect.left + rect.width / 2 + 'px';\n        this.hardShadow.style.transformOrigin = \"0 0\";\n        this.hardShadow.style.transform =\n            (((this.getDirection() === 0 /* FORWARD */) && (this.shadow.progress > 100)) ||\n                ((this.getDirection() === 1 /* BACK */) && (this.shadow.progress <= 100)))\n                ? this.hardShadow.style.transform = 'translate3d(0, 0, 0) rotateY(180deg)'\n                : this.hardShadow.style.transform = 'translate3d(0, 0, 0)';\n    }\n    drawInnerShadow() {\n        const rect = this.getRect();\n        const innerShadowSize = this.shadow.width * 3 / 4;\n        const shadowTranslate = (this.getDirection() === 0 /* FORWARD */)\n            ? innerShadowSize\n            : 0;\n        const shadowDirection = (this.getDirection() === 0 /* FORWARD */)\n            ? \"to left\"\n            : \"to right\";\n        const shadowPos = this.convertToGlobal(this.shadow.pos);\n        const angle = this.shadow.angle + 3 * Math.PI / 2;\n        this.innerShadow.style.width = innerShadowSize + 'px';\n        this.innerShadow.style.height = rect.height * 2 + 'px';\n        this.innerShadow.style.background = \"linear-gradient(\" + shadowDirection + \", \" +\n            \"rgba(0, 0, 0, \" + this.shadow.opacity + \") 5%, \" +\n            \"rgba(0, 0, 0, 0.05) 15%,\" +\n            \"rgba(0, 0, 0, \" + this.shadow.opacity + \") 35%, \" +\n            \"rgba(0, 0, 0, 0) 100% \" +\n            \")\";\n        this.innerShadow.style.transformOrigin = shadowTranslate + \"px 100px\";\n        this.innerShadow.style.transform = \"translate3d(\" + (shadowPos.x - shadowTranslate) + \"px, \" + (shadowPos.y - 100) + \"px, 0) rotate(\" + angle + \"rad)\";\n        const clip = [this.pageRect.topLeft, this.pageRect.topRight,\n            this.pageRect.bottomRight, this.pageRect.bottomLeft];\n        let polygon = 'polygon( ';\n        for (const p of clip) {\n            let g = (this.getDirection() === 1 /* BACK */)\n                ? {\n                    x: -p.x + this.shadow.pos.x,\n                    y: p.y - this.shadow.pos.y\n                }\n                : {\n                    x: p.x - this.shadow.pos.x,\n                    y: p.y - this.shadow.pos.y\n                };\n            g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n            polygon += g.x + 'px ' + g.y + 'px, ';\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.innerShadow.style.clipPath = polygon;\n        this.innerShadow.style.setProperty('-webkit-clip-path', polygon);\n    }\n    drawOuterShadow() {\n        const rect = this.getRect();\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        const angle = this.shadow.angle + 3 * Math.PI / 2;\n        const shadowTranslate = (this.getDirection() === 1 /* BACK */)\n            ? this.shadow.width\n            : 0;\n        const shadowDirection = (this.getDirection() === 0 /* FORWARD */)\n            ? \"to right\"\n            : \"to left\";\n        this.outerShadow.style.width = this.shadow.width + 'px';\n        this.outerShadow.style.height = rect.height * 2 + 'px';\n        this.outerShadow.style.background = \"linear-gradient(\" + shadowDirection + \", rgba(0, 0, 0, \" + this.shadow.opacity + \"), rgba(0, 0, 0, 0))\";\n        this.outerShadow.style.transformOrigin = shadowTranslate + \"px 100px\"; //\n        this.outerShadow.style.transform = \"translate3d(\" + (shadowPos.x - shadowTranslate) + \"px, \" + (shadowPos.y - 100) + \"px, 0) rotate(\" + angle + \"rad)\";\n        const clip = [];\n        clip.push({ x: 0, y: 0 }, { x: rect.pageWidth, y: 0 }, { x: rect.pageWidth, y: rect.height }, { x: 0, y: rect.height });\n        let polygon = 'polygon( ';\n        for (const p of clip) {\n            if (p !== null) {\n                let g = (this.getDirection() === 1 /* BACK */)\n                    ? {\n                        x: -p.x + this.shadow.pos.x,\n                        y: p.y - this.shadow.pos.y\n                    }\n                    : {\n                        x: p.x - this.shadow.pos.x,\n                        y: p.y - this.shadow.pos.y\n                    };\n                g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n                polygon += g.x + 'px ' + g.y + 'px, ';\n            }\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.outerShadow.style.clipPath = polygon;\n        this.outerShadow.style.setProperty('-webkit-clip-path', polygon);\n    }\n    drawLeftPage() {\n        if (this.leftPage === null)\n            return;\n        if (this.orientation !== \"portrait\" /* PORTRAIT */) {\n            if (this.leftPage.getDrawingDensity() === \"soft\" /* SOFT */) {\n                this.leftPage.simpleDraw(0 /* LEFT */);\n            }\n            else {\n                if ((this.direction === 1 /* BACK */) && (this.flippingPage !== null)) {\n                    this.leftPage.getElement().style.zIndex =\n                        (this.getSettings().startZIndex + 4).toString(10);\n                    this.leftPage.clearSaved();\n                    this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\n                    this.leftPage.draw(this.flippingPage.getDrawingDensity());\n                }\n                else {\n                    this.leftPage.simpleDraw(0 /* LEFT */);\n                }\n            }\n        }\n        else {\n            this.leftPage.clearSaved();\n        }\n    }\n    drawRightPage() {\n        if (this.rightPage === null)\n            return;\n        if (this.rightPage.getDrawingDensity() === \"soft\" /* SOFT */) {\n            this.rightPage.simpleDraw(1 /* RIGHT */);\n        }\n        else {\n            if ((this.direction === 0 /* FORWARD */) && (this.flippingPage !== null)) {\n                this.rightPage.getElement().style.zIndex =\n                    (this.getSettings().startZIndex + 4).toString(10);\n                this.rightPage.clearSaved();\n                this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle());\n                this.rightPage.draw(this.flippingPage.getDrawingDensity());\n            }\n            else {\n                this.rightPage.simpleDraw(1 /* RIGHT */);\n            }\n        }\n    }\n    drawBottomPage() {\n        if (this.bottomPage === null)\n            return;\n        const tempDensity = this.flippingPage != null\n            ? this.flippingPage.getDrawingDensity()\n            : null;\n        if (!((this.orientation === \"portrait\" /* PORTRAIT */) &&\n            (this.direction === 1 /* BACK */))) {\n            this.bottomPage.getElement().style.zIndex =\n                (this.getSettings().startZIndex + 3).toString(10);\n            this.bottomPage.draw(tempDensity);\n        }\n    }\n    drawFrame(timer) {\n        this.clear();\n        this.drawLeftPage();\n        this.drawRightPage();\n        this.drawBottomPage();\n        if (this.flippingPage != null) {\n            this.flippingPage.getElement().style.zIndex =\n                (this.getSettings().startZIndex + 4).toString(10);\n            this.flippingPage.draw();\n        }\n        if ((this.shadow != null) && (this.flippingPage !== null)) {\n            if (this.flippingPage.getDrawingDensity() === \"soft\" /* SOFT */) {\n                this.drawOuterShadow();\n                this.drawInnerShadow();\n            }\n            else {\n                this.drawHardOuterShadow();\n                this.drawHardInnerShadow();\n            }\n        }\n    }\n    clear() {\n        const workedPages = [];\n        if (this.leftPage)\n            workedPages.push(this.leftPage.getElement());\n        if (this.rightPage)\n            workedPages.push(this.rightPage.getElement());\n        if (this.flippingPage)\n            workedPages.push(this.flippingPage.getElement());\n        if (this.bottomPage)\n            workedPages.push(this.bottomPage.getElement());\n        for (const item of this.items) {\n            if (!workedPages.includes(item)) {\n                item.style.display = \"none\";\n                item.style.zIndex = (this.getSettings().startZIndex + 1).toString(10);\n                item.style.transform = \"\";\n            }\n        }\n    }\n    setRightPage(page) {\n        if ((this.rightPage !== null) && (page !== this.rightPage))\n            this.rightPage.clearSaved();\n        super.setRightPage(page);\n    }\n    setLeftPage(page) {\n        if ((this.leftPage !== null) && (page !== this.rightPage))\n            this.leftPage.clearSaved();\n        super.setLeftPage(page);\n    }\n    update() {\n        super.update();\n        if (this.rightPage !== null) {\n            this.rightPage.setOrientation(1 /* RIGHT */);\n            this.rightPage.clearSaved();\n        }\n        if (this.leftPage !== null) {\n            this.leftPage.setOrientation(0 /* LEFT */);\n            this.leftPage.clearSaved();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Render/HTMLRender.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/Render.ts":
/*!*****************************************!*\
  !*** ./src/StPageFlip/Render/Render.ts ***!
  \*****************************************/
/*! exports provided: Render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Render\", function() { return Render; });\nclass Render {\n    constructor(app, setting) {\n        this.leftPage = null;\n        this.rightPage = null;\n        this.flippingPage = null;\n        this.bottomPage = null;\n        this.shadow = null;\n        this.pageRect = null;\n        this.animation = null;\n        this.timer = 0;\n        this.direction = null;\n        this.orientation = null;\n        this.boundsRect = null;\n        this.setting = setting;\n        this.app = app;\n    }\n    drawShadow(pos, angle, t, direction, length) {\n        if (!this.app.getSettings().drawShadow)\n            return;\n        const maxShadowOpacity = 100 * this.getSettings().maxShadowOpacity;\n        this.shadow = {\n            pos,\n            angle,\n            width: (this.getRect().pageWidth * 3 / 4) * t / 100,\n            opacity: (100 - t) * maxShadowOpacity / 100 / 100,\n            direction,\n            length,\n            progress: t * 2\n        };\n    }\n    clearShadow() {\n        this.shadow = null;\n    }\n    setPageRect(pageRect) {\n        this.pageRect = pageRect;\n    }\n    getOrientation() {\n        return this.orientation;\n    }\n    startAnimation(frames, duration, onAnimateEnd) {\n        this.finishAnimation();\n        this.animation = {\n            frames,\n            duration,\n            durationFrame: duration / frames.length,\n            onAnimateEnd,\n            startedAt: this.timer\n        };\n    }\n    finishAnimation() {\n        if (this.animation !== null) {\n            this.animation.frames[this.animation.frames.length - 1]();\n            if (this.animation.onAnimateEnd !== null) {\n                this.animation.onAnimateEnd();\n            }\n        }\n        this.animation = null;\n    }\n    render(timer) {\n        if (this.animation !== null) {\n            const frameIndex = Math.round((timer - this.animation.startedAt) / this.animation.durationFrame);\n            if (frameIndex < this.animation.frames.length) {\n                this.animation.frames[frameIndex]();\n            }\n            else {\n                this.animation.onAnimateEnd();\n                this.animation = null;\n            }\n        }\n        this.timer = timer;\n        this.drawFrame(timer);\n    }\n    getRect() {\n        if (this.boundsRect === null)\n            this.calculateBoundsRect();\n        return this.boundsRect;\n    }\n    calculateBoundsRect() {\n        let orientation = \"landscape\" /* LANDSCAPE */;\n        const blockWidth = this.getBlockWidth();\n        const middlePoint = {\n            x: blockWidth / 2, y: this.getBlockHeight() / 2\n        };\n        const ratio = this.setting.width / this.setting.height;\n        let pageWidth = this.setting.width;\n        let pageHeight = this.setting.height;\n        let left = middlePoint.x - pageWidth;\n        if (this.setting.size === \"stretch\" /* STRETCH */) {\n            if (blockWidth < this.setting.minWidth * 2)\n                if (this.app.getSettings().usePortrait)\n                    orientation = \"portrait\" /* PORTRAIT */;\n            pageWidth = (orientation === \"portrait\" /* PORTRAIT */)\n                ? this.getBlockWidth()\n                : this.getBlockWidth() / 2;\n            if (pageWidth > this.setting.maxWidth)\n                pageWidth = this.setting.maxWidth;\n            pageHeight = pageWidth / ratio;\n            if (pageHeight > this.getBlockHeight()) {\n                pageHeight = this.getBlockHeight();\n                pageWidth = pageHeight * ratio;\n            }\n            left = (orientation === \"portrait\" /* PORTRAIT */)\n                ? middlePoint.x - pageWidth / 2 - pageWidth\n                : middlePoint.x - pageWidth;\n        }\n        else {\n            if (blockWidth < pageWidth * 2) {\n                if (this.app.getSettings().usePortrait) {\n                    orientation = \"portrait\" /* PORTRAIT */;\n                    left = middlePoint.x - pageWidth / 2 - pageWidth;\n                }\n            }\n        }\n        this.boundsRect = {\n            left: left,\n            top: middlePoint.y - (pageHeight / 2),\n            width: pageWidth * 2,\n            height: pageHeight,\n            pageWidth: pageWidth\n        };\n        return orientation;\n    }\n    update() {\n        this.boundsRect = null;\n        const orientation = this.calculateBoundsRect();\n        if (this.orientation !== orientation) {\n            this.orientation = orientation;\n            this.app.updateOrientation(orientation);\n        }\n    }\n    convertToBook(pos) {\n        const rect = this.getRect();\n        return {\n            x: pos.x - rect.left,\n            y: pos.y - rect.top\n        };\n    }\n    convertToPage(pos, direction) {\n        if (!direction)\n            direction = this.direction;\n        const rect = this.getRect();\n        const x = direction === 0 /* FORWARD */\n            ? (pos.x - rect.left - rect.width / 2)\n            : (rect.width / 2 - pos.x + rect.left);\n        return {\n            x,\n            y: pos.y - rect.top\n        };\n    }\n    convertToGlobal(pos, direction) {\n        if (!direction)\n            direction = this.direction;\n        if (pos == null)\n            return null;\n        const rect = this.getRect();\n        const x = direction === 0 /* FORWARD */\n            ? (pos.x + rect.left + rect.width / 2)\n            : rect.width / 2 - pos.x + rect.left;\n        return {\n            x,\n            y: pos.y + rect.top\n        };\n    }\n    convertRectToGlobal(rect, direction) {\n        if (!direction)\n            direction = this.direction;\n        return {\n            topLeft: this.convertToGlobal(rect.topLeft, direction),\n            topRight: this.convertToGlobal(rect.topRight, direction),\n            bottomLeft: this.convertToGlobal(rect.bottomLeft, direction),\n            bottomRight: this.convertToGlobal(rect.bottomRight, direction)\n        };\n    }\n    start() {\n        this.update();\n        const loop = (timer) => {\n            this.render(timer);\n            requestAnimationFrame(loop);\n        };\n        requestAnimationFrame(loop);\n    }\n    setDirection(direction) {\n        this.direction = direction;\n    }\n    getDirection() {\n        return this.direction;\n    }\n    setRightPage(page) {\n        if (page !== null)\n            page.setOrientation(1 /* RIGHT */);\n        this.rightPage = page;\n    }\n    setLeftPage(page) {\n        if (page !== null)\n            page.setOrientation(0 /* LEFT */);\n        this.leftPage = page;\n    }\n    setBottomPage(page) {\n        if (page !== null)\n            page.setOrientation((this.direction === 1 /* BACK */)\n                ? 0 /* LEFT */\n                : 1 /* RIGHT */);\n        this.bottomPage = page;\n    }\n    setFlippingPage(page) {\n        if (page !== null)\n            page.setOrientation(((this.direction === 0 /* FORWARD */) && (this.orientation !== \"portrait\" /* PORTRAIT */))\n                ? 0 /* LEFT */\n                : 1 /* RIGHT */);\n        this.flippingPage = page;\n    }\n    getSettings() {\n        return this.app.getSettings();\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Render/Render.ts?");

/***/ }),

/***/ "./src/StPageFlip/Settings.ts":
/*!************************************!*\
  !*** ./src/StPageFlip/Settings.ts ***!
  \************************************/
/*! exports provided: Settings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Settings\", function() { return Settings; });\nclass Settings {\n    constructor() {\n        this._default = {\n            startPage: 0,\n            size: \"fixed\" /* FIXED */,\n            width: 0,\n            height: 0,\n            minWidth: 0,\n            maxWidth: 0,\n            minHeight: 0,\n            maxHeight: 0,\n            drawShadow: true,\n            flippingTime: 1000,\n            usePortrait: true,\n            startZIndex: 0,\n            autoSize: true,\n            maxShadowOpacity: 1,\n            showCover: false\n        };\n    }\n    getSettings(userSetting) {\n        const result = this._default;\n        Object.assign(result, userSetting);\n        if ((result.size !== \"stretch\" /* STRETCH */) && (result.size !== \"fixed\" /* FIXED */))\n            throw new Error('Invalid size type. Available only \"fixed\" and \"stretch\" value');\n        if ((result.width <= 0) || (result.height <= 0))\n            throw new Error('Invalid width or height');\n        if (result.flippingTime <= 0)\n            throw new Error('Invalid flipping time');\n        if (result.minWidth <= 0)\n            result.minWidth = result.width;\n        if (result.maxWidth < result.minWidth)\n            result.maxWidth = result.minWidth;\n        if (result.minHeight <= 0)\n            result.minHeight = result.height;\n        if (result.maxHeight < result.minHeight)\n            result.maxHeight = result.minHeight;\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/Settings.ts?");

/***/ }),

/***/ "./src/StPageFlip/Style/stPagePlip.css":
/*!*********************************************!*\
  !*** ./src/StPageFlip/Style/stPagePlip.css ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js!./stPagePlip.css */ \"./node_modules/css-loader/dist/cjs.js!./src/StPageFlip/Style/stPagePlip.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack://St/./src/StPageFlip/Style/stPagePlip.css?");

/***/ }),

/***/ "./src/StPageFlip/UI/CanvasUI.ts":
/*!***************************************!*\
  !*** ./src/StPageFlip/UI/CanvasUI.ts ***!
  \***************************************/
/*! exports provided: CanvasUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasUI\", function() { return CanvasUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/StPageFlip/UI/UI.ts\");\n\nclass CanvasUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\n    constructor(inBlock, app, setting) {\n        super(inBlock, app, setting);\n        this.wrapper.innerHTML = '<canvas class=\"stf__canvas\"></canvas>';\n        this.canvas = inBlock.querySelectorAll('canvas')[0];\n        window.addEventListener('resize', () => {\n            this.update();\n        }, false);\n        this.distElement = this.canvas;\n        this.resizeCanvas();\n        this.setHandlers();\n    }\n    resizeCanvas() {\n        const cs = getComputedStyle(this.canvas);\n        const width = parseInt(cs.getPropertyValue('width'), 10);\n        const height = parseInt(cs.getPropertyValue('height'), 10);\n        this.canvas.width = width;\n        this.canvas.height = height;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n    update() {\n        this.resizeCanvas();\n        this.app.getRender().update();\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/UI/CanvasUI.ts?");

/***/ }),

/***/ "./src/StPageFlip/UI/HTMLUI.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/UI/HTMLUI.ts ***!
  \*************************************/
/*! exports provided: HTMLUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLUI\", function() { return HTMLUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/StPageFlip/UI/UI.ts\");\n\nclass HTMLUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\n    constructor(inBlock, app, setting, items) {\n        super(inBlock, app, setting);\n        this.wrapper.insertAdjacentHTML('afterbegin', '<div class=\"stf__block\"></div>');\n        this.distElement = inBlock.querySelector('.stf__block');\n        for (const item of items) {\n            this.distElement.appendChild(item);\n        }\n        window.addEventListener('resize', () => {\n            this.update();\n        }, false);\n        this.setHandlers();\n    }\n    update() {\n        this.app.getRender().update();\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/UI/HTMLUI.ts?");

/***/ }),

/***/ "./src/StPageFlip/UI/UI.ts":
/*!*********************************!*\
  !*** ./src/StPageFlip/UI/UI.ts ***!
  \*********************************/
/*! exports provided: UI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UI\", function() { return UI; });\nclass UI {\n    constructor(inBlock, app, setting) {\n        this.touchPoint = null;\n        this.swipeTimeout = 250;\n        this.swipeDistance = 80;\n        inBlock.classList.add('stf__parent');\n        inBlock.insertAdjacentHTML('afterbegin', '<div class=\"stf__wrapper\"></div>');\n        this.wrapper = inBlock.querySelector('.stf__wrapper');\n        this.app = app;\n        const k = this.app.getSettings().usePortrait ? 1 : 2;\n        inBlock.style.minWidth = setting.minWidth * k + 'px';\n        inBlock.style.minHeight = setting.minHeight * k + 'px';\n        if (setting.size === \"fixed\" /* FIXED */) {\n            inBlock.style.minWidth = setting.width * k + 'px';\n            inBlock.style.minHeight = setting.height * k + 'px';\n        }\n        if (setting.autoSize) {\n            inBlock.style.width = '100%';\n            inBlock.style.maxWidth = setting.maxWidth * 2 + 'px';\n        }\n        inBlock.style.display = 'block';\n    }\n    getDistElement() {\n        return this.distElement;\n    }\n    getWrapper() {\n        return this.wrapper;\n    }\n    setOrientationStyle(orientation) {\n        this.wrapper.classList.remove('--portrait', '--landscape');\n        if (orientation === \"portrait\" /* PORTRAIT */) {\n            if (this.app.getSettings().autoSize)\n                this.wrapper.style.paddingBottom = (this.app.getSettings().height / this.app.getSettings().width) * 100 + '%';\n            this.wrapper.classList.add('--portrait');\n        }\n        else {\n            if (this.app.getSettings().autoSize)\n                this.wrapper.style.paddingBottom = (this.app.getSettings().height / (this.app.getSettings().width * 2)) * 100 + '%';\n            this.wrapper.classList.add('--landscape');\n        }\n        this.update();\n    }\n    setHandlers() {\n        this.distElement.addEventListener('mousedown', (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.startUserTouch(pos);\n            e.preventDefault();\n        });\n        this.distElement.addEventListener('touchstart', (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                const pos = this.getMousePos(t.clientX, t.clientY);\n                this.touchPoint = {\n                    point: pos,\n                    time: Date.now()\n                };\n                setTimeout(() => {\n                    if (this.touchPoint !== null)\n                        this.app.startUserTouch(pos);\n                }, this.swipeTimeout);\n                e.preventDefault();\n            }\n        });\n        window.addEventListener('mousemove', (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.userMove(pos, false);\n        });\n        window.addEventListener('touchmove', (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                this.app.userMove(this.getMousePos(t.clientX, t.clientY), true);\n            }\n        });\n        window.addEventListener('mouseup', (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.userStop(pos);\n        });\n        window.addEventListener('touchend', (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                const pos = this.getMousePos(t.clientX, t.clientY);\n                let isSwipe = false;\n                if (this.touchPoint !== null) {\n                    const dx = pos.x - this.touchPoint.point.x;\n                    const distY = Math.abs(pos.y - this.touchPoint.point.y);\n                    if ((Math.abs(dx) > this.swipeDistance) &&\n                        (distY < this.swipeDistance * 2) &&\n                        ((Date.now() - this.touchPoint.time) < this.swipeTimeout)) {\n                        if (dx > 0) {\n                            this.app.flipPrev((this.touchPoint.point.y < this.app.getRender().getRect().height / 2)\n                                ? \"top\" /* TOP */\n                                : \"bottom\" /* BOTTOM */);\n                        }\n                        else {\n                            this.app.flipNext((this.touchPoint.point.y < this.app.getRender().getRect().height / 2)\n                                ? \"top\" /* TOP */\n                                : \"bottom\" /* BOTTOM */);\n                        }\n                        isSwipe = true;\n                    }\n                    this.touchPoint = null;\n                }\n                this.app.userStop(pos, isSwipe);\n            }\n        });\n    }\n    getMousePos(x, y) {\n        const rect = this.distElement.getBoundingClientRect();\n        return {\n            x: x - rect.left,\n            y: y - rect.top\n        };\n    }\n}\n\n\n//# sourceURL=webpack://St/./src/StPageFlip/UI/UI.ts?");

/***/ })

/******/ });