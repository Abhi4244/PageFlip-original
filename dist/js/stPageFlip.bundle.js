var StPageFlip =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/StPageFlip/App.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/StPageFlip/App.ts":
/*!*******************************!*\
  !*** ./src/StPageFlip/App.ts ***!
  \*******************************/
/*! exports provided: SizeType, App */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SizeType\", function() { return SizeType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"App\", function() { return App; });\n/* harmony import */ var _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Collection/ImagePageCollection */ \"./src/StPageFlip/Collection/ImagePageCollection.ts\");\n/* harmony import */ var _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection/HTMLPageCollection */ \"./src/StPageFlip/Collection/HTMLPageCollection.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n/* harmony import */ var _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Render/CanvasRender */ \"./src/StPageFlip/Render/CanvasRender.ts\");\n/* harmony import */ var _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UI/HTMLUI */ \"./src/StPageFlip/UI/HTMLUI.ts\");\n/* harmony import */ var _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UI/CanvasUI */ \"./src/StPageFlip/UI/CanvasUI.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Event/EventObject */ \"./src/StPageFlip/Event/EventObject.ts\");\n/* harmony import */ var _Render_Render__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Render/Render */ \"./src/StPageFlip/Render/Render.ts\");\n/* harmony import */ var _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Render/HTMLRender */ \"./src/StPageFlip/Render/HTMLRender.ts\");\n\n\n\n\n\n\n\n\n\n\nvar SizeType;\n(function (SizeType) {\n    SizeType[SizeType[\"FIXED\"] = 0] = \"FIXED\";\n    SizeType[SizeType[\"STRETCH\"] = 1] = \"STRETCH\";\n})(SizeType || (SizeType = {}));\nclass App extends _Event_EventObject__WEBPACK_IMPORTED_MODULE_7__[\"EventObject\"] {\n    constructor(inBlock, setting) {\n        super();\n        this.isUserTouch = false;\n        this.isUserMove = false;\n        this.pages = null;\n        this.currentPage = 0;\n        this.setting = {\n            width: 600,\n            height: 800,\n            size: SizeType.STRETCH,\n            minWidth: 150,\n            maxWidth: 900,\n            minHeight: 300,\n            maxHeight: 2200,\n            startPage: 2\n        };\n        this.block = inBlock;\n    }\n    update() {\n        this.pages.show(this.currentPage);\n    }\n    turnToPrevPage() {\n        const dp = this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_8__[\"Orientation\"].PORTRAIT ? 1 : 2;\n        if (this.currentPage < dp)\n            return;\n        this.currentPage -= dp;\n        this.pages.show(this.currentPage);\n        this.trigger('flip', this, this.currentPage);\n    }\n    turnToNextPage() {\n        const dp = this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_8__[\"Orientation\"].PORTRAIT ? 1 : 2;\n        if (this.currentPage > this.pages.getPageCount() - dp)\n            return;\n        this.currentPage += dp;\n        this.pages.show(this.currentPage);\n        this.trigger('flip', this, this.currentPage);\n    }\n    turnToPage(pageNum) {\n        if (!this.checkPage(pageNum))\n            return;\n        this.currentPage = pageNum;\n        this.pages.show(this.currentPage);\n        this.trigger('flip', this, this.currentPage);\n    }\n    loadFromImages(imagesHref) {\n        const ui = new _UI_CanvasUI__WEBPACK_IMPORTED_MODULE_5__[\"CanvasUI\"](this.block, this, this.setting);\n        const canvas = ui.getCanvas();\n        this.render = new _Render_CanvasRender__WEBPACK_IMPORTED_MODULE_3__[\"CanvasRender\"](canvas, this.setting);\n        this.flip = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\n        this.render.start();\n        this.pages = new _Collection_ImagePageCollection__WEBPACK_IMPORTED_MODULE_0__[\"ImagePageCollection\"](this.render, imagesHref);\n        this.pages.load();\n        this.pages.show(this.setting.startPage);\n        this.currentPage = this.setting.startPage;\n        this.trigger('flip', this, this.currentPage);\n    }\n    loadFromHTML() {\n        const ui = new _UI_HTMLUI__WEBPACK_IMPORTED_MODULE_4__[\"HTMLUI\"](this.block, this, this.setting);\n        this.render = new _Render_HTMLRender__WEBPACK_IMPORTED_MODULE_9__[\"HTMLRender\"](ui.getDistElement(), this.setting);\n        this.flip = new _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"Flip\"](this.render, this);\n        this.render.start();\n        this.pages = new _Collection_HTMLPageCollection__WEBPACK_IMPORTED_MODULE_1__[\"HTMLPageCollection\"](this.render, ui.getDistElement());\n        this.pages.load();\n        this.pages.show(this.setting.startPage);\n        this.currentPage = this.setting.startPage;\n        this.trigger('flip', this, this.currentPage);\n    }\n    updateState(newState) {\n        this.trigger('changeState', this, newState);\n    }\n    getPageCount() {\n        return this.pages.getPageCount();\n    }\n    getCurrentPageIndex() {\n        return this.currentPage;\n    }\n    getCurrentPage() {\n        return this.pages.getPage(this.currentPage);\n    }\n    getPage(pageNum) {\n        return this.pages.getPage(pageNum);\n    }\n    startUserTouch(pos) {\n        this.mousePosition = pos;\n        this.isUserTouch = true;\n        this.isUserMove = false;\n    }\n    userMove(pos) {\n        if (!this.isUserTouch) {\n            this.flip.showCorner(pos);\n        }\n        else {\n            if (_Helper__WEBPACK_IMPORTED_MODULE_6__[\"Helper\"].GetDestinationFromTwoPoint(this.mousePosition, pos) > 5) {\n                this.isUserMove = true;\n                this.flip.fold(pos);\n            }\n        }\n    }\n    userStop(pos) {\n        if (this.isUserTouch) {\n            this.isUserTouch = false;\n            if (!this.isUserMove)\n                this.flip.flip(pos);\n            else\n                this.flip.stopMove();\n        }\n    }\n    checkPage(page) {\n        return ((page >= 0) && (page < this.pages.getPageCount()));\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/App.ts?");

/***/ }),

/***/ "./src/StPageFlip/Collection/HTMLPageCollection.ts":
/*!*********************************************************!*\
  !*** ./src/StPageFlip/Collection/HTMLPageCollection.ts ***!
  \*********************************************************/
/*! exports provided: HTMLPageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPageCollection\", function() { return HTMLPageCollection; });\n/* harmony import */ var _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/HTMLPage */ \"./src/StPageFlip/Page/HTMLPage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/StPageFlip/Collection/PageCollection.ts\");\n\n\nclass HTMLPageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\n    constructor(render, element) {\n        super(render);\n        this.element = element;\n        this.pagesElement = element.querySelectorAll(\".stf__item\");\n    }\n    async load() {\n        const loadPromises = [];\n        for (const pageElement of this.pagesElement) {\n            const page = new _Page_HTMLPage__WEBPACK_IMPORTED_MODULE_0__[\"HTMLPage\"](this.render, pageElement);\n            loadPromises.push(page.load());\n            this.pages.push(page);\n        }\n        return Promise.all(loadPromises);\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Collection/HTMLPageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Collection/ImagePageCollection.ts":
/*!**********************************************************!*\
  !*** ./src/StPageFlip/Collection/ImagePageCollection.ts ***!
  \**********************************************************/
/*! exports provided: ImagePageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePageCollection\", function() { return ImagePageCollection; });\n/* harmony import */ var _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Page/ImagePage */ \"./src/StPageFlip/Page/ImagePage.ts\");\n/* harmony import */ var _PageCollection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageCollection */ \"./src/StPageFlip/Collection/PageCollection.ts\");\n\n\nclass ImagePageCollection extends _PageCollection__WEBPACK_IMPORTED_MODULE_1__[\"PageCollection\"] {\n    constructor(render, imagesHref) {\n        super(render);\n        this.imagesHref = imagesHref;\n    }\n    async load() {\n        const loadPromises = [];\n        for (const href of this.imagesHref) {\n            const page = new _Page_ImagePage__WEBPACK_IMPORTED_MODULE_0__[\"ImagePage\"](this.render, href);\n            loadPromises.push(page.load());\n            this.pages.push(page);\n        }\n        return Promise.all(loadPromises);\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Collection/ImagePageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Collection/PageCollection.ts":
/*!*****************************************************!*\
  !*** ./src/StPageFlip/Collection/PageCollection.ts ***!
  \*****************************************************/
/*! exports provided: PageCollection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageCollection\", function() { return PageCollection; });\n/* harmony import */ var _Render_Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Render/Render */ \"./src/StPageFlip/Render/Render.ts\");\n\nclass PageCollection {\n    constructor(render) {\n        this.pages = [];\n        this.render = render;\n    }\n    getPageCount() {\n        return this.pages.length;\n    }\n    getPages() {\n        return this.pages;\n    }\n    getPage(pageIndex) {\n        if ((pageIndex >= 0) && (pageIndex < this.pages.length)) {\n            return this.pages[pageIndex];\n        }\n        throw new Error('Invalid page number');\n    }\n    /**\n     * Render page at pageNum without transform\n     *\n     * @param pageNum\n     */\n    show(pageNum) {\n        if ((pageNum < 0) || (pageNum >= this.pages.length)) {\n            return;\n        }\n        if (this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT) {\n            this.render.setLeftPage(null);\n            this.render.setRightPage(this.pages[pageNum]);\n        }\n        else {\n            if (pageNum === (this.pages.length - 1)) {\n                pageNum--;\n            }\n            this.render.setLeftPage(this.pages[pageNum]);\n            this.render.setRightPage(this.pages[pageNum + 1]);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Collection/PageCollection.ts?");

/***/ }),

/***/ "./src/StPageFlip/Event/EventObject.ts":
/*!*********************************************!*\
  !*** ./src/StPageFlip/Event/EventObject.ts ***!
  \*********************************************/
/*! exports provided: EventObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventObject\", function() { return EventObject; });\nclass EventObject {\n    constructor() {\n        this.events = {};\n    }\n    on(eventName, callback) {\n        if (!(eventName in this.events)) {\n            this.events[eventName] = [callback];\n        }\n        else {\n            this.events[eventName].push(callback);\n        }\n        return this;\n    }\n    off(event) {\n        delete this.events[event];\n    }\n    trigger(eventName, app, data = null) {\n        if (eventName in this.events) {\n            this.events[eventName].forEach((callback) => {\n                callback({\n                    data: data,\n                    object: app\n                });\n            });\n        }\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Event/EventObject.ts?");

/***/ }),

/***/ "./src/StPageFlip/Flip/Flip.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/Flip/Flip.ts ***!
  \*************************************/
/*! exports provided: FlipDirection, FlipCorner, FlippingState, Flip */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlipDirection\", function() { return FlipDirection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlipCorner\", function() { return FlipCorner; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlippingState\", function() { return FlippingState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Flip\", function() { return Flip; });\n/* harmony import */ var _Render_Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Render/Render */ \"./src/StPageFlip/Render/Render.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _FlipCalculation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlipCalculation */ \"./src/StPageFlip/Flip/FlipCalculation.ts\");\n\n\n\nvar FlipDirection;\n(function (FlipDirection) {\n    FlipDirection[FlipDirection[\"FORWARD\"] = 0] = \"FORWARD\";\n    FlipDirection[FlipDirection[\"BACK\"] = 1] = \"BACK\";\n})(FlipDirection || (FlipDirection = {}));\nvar FlipCorner;\n(function (FlipCorner) {\n    FlipCorner[FlipCorner[\"TOP\"] = 0] = \"TOP\";\n    FlipCorner[FlipCorner[\"BOTTOM\"] = 1] = \"BOTTOM\";\n})(FlipCorner || (FlipCorner = {}));\nvar FlippingState;\n(function (FlippingState) {\n    FlippingState[\"USER_FOLD\"] = \"user_fold\";\n    FlippingState[\"FOLD_CORNER\"] = \"fold_corner\";\n    FlippingState[\"FLIPPING\"] = \"flipping\";\n    FlippingState[\"READ\"] = \"read\";\n})(FlippingState || (FlippingState = {}));\nclass Flip {\n    constructor(render, app) {\n        this.flippingPage = null;\n        this.bottomPage = null;\n        this.calc = null;\n        this.state = FlippingState.READ;\n        this.render = render;\n        this.app = app;\n    }\n    getCalculation() {\n        return this.calc;\n    }\n    start(globalPos) {\n        this.reset();\n        const bookPos = this.render.convertToBook(globalPos);\n        const rect = this.getBoundsRect();\n        let direction = FlipDirection.FORWARD;\n        if (this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT) {\n            if ((bookPos.x - rect.pageWidth) <= rect.width / 5)\n                direction = FlipDirection.BACK;\n        }\n        else if (bookPos.x < rect.width / 2) {\n            direction = FlipDirection.BACK;\n        }\n        const flipCorner = (bookPos.y >= rect.height / 2)\n            ? FlipCorner.BOTTOM\n            : FlipCorner.TOP;\n        if (!this.checkDirection(direction))\n            return false;\n        try {\n            this.flippingPage = this.getFlippingPage(direction);\n            this.bottomPage = this.getBottomPage(direction);\n            if (!this.flippingPage || !this.bottomPage)\n                return false;\n            this.render.setDirection(direction);\n            this.calc = new _FlipCalculation__WEBPACK_IMPORTED_MODULE_2__[\"FlipCalculation\"](direction, flipCorner, rect.pageWidth, rect.height);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    showCorner(globalPos) {\n        if (!this.checkState(FlippingState.READ, FlippingState.FOLD_CORNER))\n            return;\n        const rect = this.getBoundsRect();\n        const pageWidth = rect.pageWidth;\n        const operatingDistance = Math.sqrt(Math.pow(pageWidth, 2) + Math.pow(rect.height, 2)) / 5;\n        const bookPos = this.render.convertToBook(globalPos);\n        if (((bookPos.x > 0) && (bookPos.y > 0)) &&\n            ((bookPos.x < rect.width) && (bookPos.y < rect.height)) &&\n            ((bookPos.x < operatingDistance) || (bookPos.x > (rect.width - operatingDistance))) &&\n            ((bookPos.y < operatingDistance) || (bookPos.y > rect.height - operatingDistance))) {\n            if (this.calc === null) {\n                if (!this.start(globalPos))\n                    return;\n                this.setState(FlippingState.FOLD_CORNER);\n                this.calc.calc({ x: pageWidth - 1, y: 1 });\n                const fixedCornerSize = 50;\n                const yStart = (this.calc.getCorner() === FlipCorner.BOTTOM)\n                    ? rect.height - 1\n                    : 1;\n                const yDest = (this.calc.getCorner() === FlipCorner.BOTTOM)\n                    ? rect.height - fixedCornerSize\n                    : fixedCornerSize;\n                this.animateFlippingTo({ x: pageWidth - 1, y: yStart }, { x: pageWidth - fixedCornerSize, y: yDest }, false, false);\n            }\n            else {\n                this.do(this.render.convertToPage(globalPos));\n            }\n        }\n        else {\n            this.setState(FlippingState.READ);\n            this.render.finishAnimation();\n            this.stopMove();\n        }\n    }\n    fold(globalPos) {\n        this.setState(FlippingState.USER_FOLD);\n        if (this.calc === null)\n            this.start(globalPos);\n        this.do(this.render.convertToPage(globalPos));\n    }\n    flip(globalPos) {\n        if (this.calc !== null)\n            this.render.finishAnimation();\n        if (!this.start(globalPos))\n            return;\n        const rect = this.getBoundsRect();\n        this.setState(FlippingState.FLIPPING);\n        const topMargins = rect.height / 10;\n        const yStart = (this.calc.getCorner() === FlipCorner.BOTTOM)\n            ? rect.height - topMargins\n            : topMargins;\n        const yDest = (this.calc.getCorner() === FlipCorner.BOTTOM)\n            ? rect.height\n            : 0;\n        this.calc.calc({ x: rect.pageWidth - topMargins, y: yStart });\n        this.animateFlippingTo({ x: rect.pageWidth - topMargins, y: yStart }, { x: -rect.pageWidth, y: yDest }, true);\n    }\n    stopMove() {\n        if (this.calc === null)\n            return;\n        const pos = this.calc.getPosition();\n        const rect = this.getBoundsRect();\n        const y = this.calc.getCorner() === FlipCorner.BOTTOM\n            ? rect.height\n            : 0;\n        if (pos.x <= 0)\n            this.animateFlippingTo(pos, { x: -rect.pageWidth, y }, true);\n        else\n            this.animateFlippingTo(pos, { x: rect.pageWidth, y }, false);\n    }\n    do(pagePos) {\n        if (this.calc === null)\n            return;\n        this.calc.calc(pagePos);\n        this.flippingPage.setArea(this.calc.getFlippingClipArea());\n        this.flippingPage.setPosition(this.calc.getActiveCorner());\n        this.flippingPage.setAngle(this.calc.getAngle());\n        this.bottomPage.setArea(this.calc.getBottomClipArea());\n        this.bottomPage.setPosition(this.calc.getBottomPagePosition());\n        this.bottomPage.setAngle(0);\n        this.render.setPageRect(this.calc.getRect());\n        this.render.setBottomPage(this.bottomPage);\n        this.render.setFlippingPage(this.flippingPage);\n        this.render.drawShadow(this.calc.getShadowStartPoint(), this.calc.getShadowAngle(), this.calc.getFlippingProgress(), this.calc.getDirection(), this.calc.getShadowLength());\n    }\n    animateFlippingTo(start, dest, isTurned, needReset = true) {\n        const points = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetCordsFromTwoPoint(start, dest);\n        const frames = [];\n        for (const p of points)\n            frames.push(() => this.do(p));\n        const duration = this.getAnimationDuration(points.length);\n        this.render.startAnimation(frames, duration, () => {\n            if (isTurned) {\n                if (this.calc.getDirection() === FlipDirection.BACK)\n                    this.app.turnToPrevPage();\n                else\n                    this.app.turnToNextPage();\n            }\n            if (needReset) {\n                this.render.setBottomPage(null);\n                this.render.setFlippingPage(null);\n                this.render.clearShadow();\n                this.state = FlippingState.READ;\n                this.reset();\n            }\n        });\n    }\n    getAnimationDuration(size) {\n        if (size < 200)\n            return 400;\n        if (size < 500)\n            return 470;\n        return 1000;\n    }\n    getFlippingPage(direction) {\n        const current = this.app.getCurrentPageIndex();\n        if (this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT) {\n            return (direction === FlipDirection.FORWARD)\n                ? this.app.getPage(current)\n                : this.app.getPage(current - 1);\n        }\n        else {\n            if ((current < (this.app.getPageCount() - 1)) && (current >= 0)) {\n                return (direction === FlipDirection.FORWARD)\n                    ? this.app.getPage(current + 2)\n                    : this.app.getPage(current - 1);\n            }\n        }\n        return null;\n    }\n    getNextPage() {\n        const current = this.app.getCurrentPageIndex();\n        const dp = this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT ? 0 : 2;\n        if (current < (this.app.getPageCount() - dp))\n            return this.app.getPage(current + dp + 1);\n        return null;\n    }\n    getPrevPage() {\n        const current = this.app.getCurrentPageIndex();\n        const dp = this.render.getOrientation() === _Render_Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT ? 0 : 2;\n        if (current - dp >= 0)\n            return this.app.getPage(current - dp);\n        return null;\n    }\n    getBottomPage(direction) {\n        if (direction === FlipDirection.FORWARD)\n            return this.getNextPage();\n        return this.getPrevPage();\n    }\n    checkDirection(direction) {\n        if (direction === FlipDirection.FORWARD)\n            return (this.app.getCurrentPageIndex() <= (this.app.getPageCount() - 1));\n        return (this.app.getCurrentPageIndex() >= 1);\n    }\n    reset() {\n        this.calc = null;\n        this.flippingPage = null;\n        this.bottomPage = null;\n    }\n    getBoundsRect() {\n        return this.render.getRect();\n    }\n    getPageWidth() {\n        return this.getBoundsRect().width / 2;\n    }\n    getPageHeight() {\n        return this.getBoundsRect().height;\n    }\n    setState(newState) {\n        this.app.updateState(newState);\n        this.state = newState;\n    }\n    checkState(...states) {\n        for (const state of states)\n            if (this.state === state)\n                return true;\n        return false;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Flip/Flip.ts?");

/***/ }),

/***/ "./src/StPageFlip/Flip/FlipCalculation.ts":
/*!************************************************!*\
  !*** ./src/StPageFlip/Flip/FlipCalculation.ts ***!
  \************************************************/
/*! exports provided: FlipCalculation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlipCalculation\", function() { return FlipCalculation; });\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _Flip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n\n\nclass FlipCalculation {\n    constructor(direction, corner, pageWidth, pageHeight) {\n        this.direction = direction;\n        this.corner = corner;\n        this.pageWidth = pageWidth;\n        this.pageHeight = pageHeight;\n        this.topIntersectPoint = null;\n        this.sideIntersectPoint = null;\n        this.bottomIntersectPoint = null;\n    }\n    calc(localPos) {\n        try {\n            this.position = this.preparePosition(localPos);\n            this.calculateIntersectPoint(this.position);\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }\n    getPageRect(localPos) {\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n            return this.getRectFromBasePoint([\n                { x: 0, y: 0 },\n                { x: this.pageWidth, y: 0 },\n                { x: 0, y: this.pageHeight },\n                { x: this.pageWidth, y: this.pageHeight }\n            ], localPos);\n        }\n        return this.getRectFromBasePoint([\n            { x: 0, y: -this.pageHeight },\n            { x: this.pageWidth, y: -this.pageHeight },\n            { x: 0, y: 0 },\n            { x: this.pageWidth, y: 0 }\n        ], localPos);\n    }\n    getRectFromBasePoint(points, localPos) {\n        return {\n            topLeft: this.getRotatedPoint(points[0], localPos),\n            topRight: this.getRotatedPoint(points[1], localPos),\n            bottomLeft: this.getRotatedPoint(points[2], localPos),\n            bottomRight: this.getRotatedPoint(points[3], localPos)\n        };\n    }\n    getRotatedPoint(transformedPoint, startPoint, angle = null) {\n        if (angle === null)\n            angle = this.angle;\n        return {\n            x: transformedPoint.x * Math.cos(this.angle) + transformedPoint.y * Math.sin(this.angle) + startPoint.x,\n            y: transformedPoint.y * Math.cos(this.angle) - transformedPoint.x * Math.sin(this.angle) + startPoint.y\n        };\n    }\n    updateAngleAndGeometry(pos) {\n        this.angle = this.calculateAngle(pos);\n        this.rect = this.getPageRect(pos);\n    }\n    calculateIntersectPoint(pos) {\n        const boundRect = {\n            left: -1,\n            top: -1,\n            width: this.pageWidth + 2,\n            height: this.pageHeight + 2\n        };\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.topRight], [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.bottomLeft], [{ x: this.pageWidth, y: 0 }, { x: this.pageWidth, y: this.pageHeight }]);\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [{ x: 0, y: this.pageHeight }, { x: this.pageWidth, y: this.pageHeight }]);\n        }\n        else {\n            this.topIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.topLeft, this.rect.topRight], [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n            this.sideIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [pos, this.rect.topLeft], [{ x: this.pageWidth, y: 0 }, { x: this.pageWidth, y: this.pageHeight }]);\n            this.bottomIntersectPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByTwoSegment(boundRect, [this.rect.bottomLeft, this.rect.bottomRight], [{ x: 0, y: this.pageHeight }, { x: this.pageWidth, y: this.pageHeight }]);\n        }\n    }\n    checkPositionAtCenterLine(checkedPos, centerOne, centerTwo) {\n        let result = checkedPos;\n        const tmp = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByLineAndCircle(centerOne, this.pageWidth, result);\n        if (result !== tmp) {\n            result = tmp;\n            this.updateAngleAndGeometry(result);\n        }\n        const rad = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\n        let checkPointOne = this.rect.bottomRight;\n        let checkPointTwo = this.rect.topLeft;\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].BOTTOM) {\n            checkPointOne = this.rect.topRight;\n            checkPointTwo = this.rect.bottomLeft;\n        }\n        if (checkPointOne.x <= 0) {\n            const bottomPoint = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetIntersectByLineAndCircle(centerTwo, rad, checkPointTwo);\n            if (bottomPoint !== result) {\n                result = bottomPoint;\n                this.updateAngleAndGeometry(result);\n            }\n        }\n        return result;\n    }\n    preparePosition(pos) {\n        let result = pos;\n        this.updateAngleAndGeometry(result);\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: 0 }, { x: 0, y: this.pageHeight });\n        }\n        else {\n            result = this.checkPositionAtCenterLine(result, { x: 0, y: this.pageHeight }, { x: 0, y: 0 });\n        }\n        if ((Math.abs(result.x - this.pageWidth) < 1) && (Math.abs(result.y) < 1)) {\n            throw new Error('Point is too small');\n        }\n        return result;\n    }\n    calculateAngle(pos) {\n        const left = this.pageWidth - pos.x;\n        const top = (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].BOTTOM)\n            ? this.pageHeight - pos.y\n            : pos.y;\n        let angle = 2 * Math.acos(left / Math.sqrt(top * top + left * left));\n        if (top < 0)\n            angle = -angle;\n        const da = Math.PI - angle;\n        if (!isFinite(angle) || ((da >= 0) && (da < 0.003)))\n            throw new Error('The G point is too small');\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].BOTTOM)\n            angle = -angle;\n        return angle;\n    }\n    getAngle() {\n        if (this.direction === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD) {\n            return -this.angle;\n        }\n        return this.angle;\n    }\n    getRect() {\n        return this.rect;\n    }\n    getPosition() {\n        return this.position;\n    }\n    getActiveCorner() {\n        if (this.direction === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD) {\n            return this.rect.topLeft;\n        }\n        return this.rect.topRight;\n    }\n    getDirection() {\n        return this.direction;\n    }\n    getIntersectPoint() {\n        return {\n            top: this.topIntersectPoint,\n            bottom: this.bottomIntersectPoint,\n            side: this.sideIntersectPoint\n        };\n    }\n    getSegmentToShadowLine() {\n        const first = this.getShadowStartPoint();\n        const second = ((first !== this.sideIntersectPoint) && (this.sideIntersectPoint !== null))\n            ? this.sideIntersectPoint\n            : this.bottomIntersectPoint;\n        return [first, second];\n    }\n    getShadowStartPoint() {\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n            return this.topIntersectPoint;\n        }\n        else {\n            if (this.sideIntersectPoint !== null)\n                return this.sideIntersectPoint;\n            return this.topIntersectPoint;\n        }\n    }\n    getShadowAngle() {\n        const angle = _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetAngleFromTwoLine(this.getSegmentToShadowLine(), [{ x: 0, y: 0 }, { x: this.pageWidth, y: 0 }]);\n        if (this.direction === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD) {\n            return angle;\n        }\n        return Math.PI - angle;\n    }\n    getShadowLength() {\n        return _Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetSegmentLenght(this.getSegmentToShadowLine());\n    }\n    getFlippingProgress() {\n        return Math.abs((this.position.x - this.pageWidth) / (2 * this.pageWidth) * 100);\n    }\n    getFlippingClipArea() {\n        const result = [];\n        let clipBottom = false;\n        result.push(this.rect.topLeft);\n        result.push(this.topIntersectPoint);\n        if (this.sideIntersectPoint === null) {\n            clipBottom = true;\n        }\n        else {\n            result.push(this.sideIntersectPoint);\n            if (this.bottomIntersectPoint === null)\n                clipBottom = false;\n        }\n        result.push(this.bottomIntersectPoint);\n        if ((clipBottom) || (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].BOTTOM)) {\n            result.push(this.rect.bottomLeft);\n        }\n        return result;\n    }\n    getCorner() {\n        return this.corner;\n    }\n    getBottomClipArea() {\n        const result = [];\n        result.push(this.topIntersectPoint);\n        if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n            result.push({ x: this.pageWidth, y: 0 });\n        }\n        else {\n            if (this.topIntersectPoint !== null) {\n                result.push({ x: this.pageWidth, y: 0 });\n            }\n            result.push({ x: this.pageWidth, y: this.pageHeight });\n        }\n        if (this.sideIntersectPoint !== null) {\n            if (_Helper__WEBPACK_IMPORTED_MODULE_0__[\"Helper\"].GetDestinationFromTwoPoint(this.sideIntersectPoint, this.topIntersectPoint) >= 10)\n                result.push(this.sideIntersectPoint);\n        }\n        else {\n            if (this.corner === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipCorner\"].TOP) {\n                result.push({ x: this.pageWidth, y: this.pageHeight });\n            }\n        }\n        result.push(this.bottomIntersectPoint);\n        result.push(this.topIntersectPoint);\n        return result;\n    }\n    getBottomPagePosition() {\n        if (this.direction === _Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].BACK) {\n            return { x: this.pageWidth, y: 0 };\n        }\n        return { x: 0, y: 0 };\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Flip/FlipCalculation.ts?");

/***/ }),

/***/ "./src/StPageFlip/Helper.ts":
/*!**********************************!*\
  !*** ./src/StPageFlip/Helper.ts ***!
  \**********************************/
/*! exports provided: Helper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Helper\", function() { return Helper; });\nclass Helper {\n    static GetDestinationFromTwoPoint(point1, point2) {\n        if ((point1 === null) || (point2 === null)) {\n            return Infinity;\n        }\n        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));\n    }\n    static GetSegmentLenght(line) {\n        return Helper.GetDestinationFromTwoPoint(line[0], line[1]);\n    }\n    static GetAngleFromTwoLine(line1, line2) {\n        const A1 = line1[0].y - line1[1].y;\n        const A2 = line2[0].y - line2[1].y;\n        const B1 = line1[1].x - line1[0].x;\n        const B2 = line2[1].x - line2[0].x;\n        return Math.acos((A1 * A2 + B1 * B2) / (Math.sqrt(A1 * A1 + B1 * B1) * Math.sqrt(A2 * A2 + B2 * B2)));\n    }\n    static PointInRect(rect, pos) {\n        if (pos === null) {\n            return null;\n        }\n        if ((pos.x >= rect.left) && (pos.x <= rect.width + rect.left) &&\n            (pos.y >= rect.top) && (pos.y <= rect.top + rect.height)) {\n            return pos;\n        }\n        return null;\n    }\n    static GetRotatedPoint(transformedPoint, startPoint, angle) {\n        return {\n            x: transformedPoint.x * Math.cos(angle) + transformedPoint.y * Math.sin(angle) + startPoint.x,\n            y: transformedPoint.y * Math.cos(angle) - transformedPoint.x * Math.sin(angle) + startPoint.y\n        };\n    }\n    static GetIntersectByLineAndCircle(startPoint, radius, linePoint) {\n        if (Helper.GetDestinationFromTwoPoint(startPoint, linePoint) <= radius) {\n            return linePoint;\n        }\n        const a = startPoint.x;\n        const b = startPoint.y;\n        const n = linePoint.x;\n        const m = linePoint.y;\n        let x = Math.sqrt((Math.pow(radius, 2) * Math.pow(a - n, 2)) / (Math.pow(a - n, 2) + Math.pow(b - m, 2))) + a;\n        if (linePoint.x < 0) {\n            x *= -1;\n        }\n        let y = ((x - a) * (b - m)) / (a - n) + b;\n        if (((a - n) + b) === 0) {\n            y = radius;\n        }\n        return {\n            x,\n            y\n        };\n    }\n    static GetIntersectByTwoSegment(rectBorder, one, two) {\n        return Helper.PointInRect(rectBorder, Helper.GetIntersectByTwoLine(one, two));\n    }\n    static GetIntersectByTwoLine(one, two) {\n        const A1 = one[0].y - one[1].y;\n        const A2 = two[0].y - two[1].y;\n        const B1 = one[1].x - one[0].x;\n        const B2 = two[1].x - two[0].x;\n        const C1 = one[0].x * one[1].y - one[1].x * one[0].y;\n        const C2 = two[0].x * two[1].y - two[1].x * two[0].y;\n        const det1 = A1 * C2 - A2 * C1;\n        const det2 = B1 * C2 - B2 * C1;\n        const x = -((C1 * B2 - C2 * B1) / (A1 * B2 - A2 * B1));\n        const y = -((A1 * C2 - A2 * C1) / (A1 * B2 - A2 * B1));\n        if (isFinite(x) && isFinite(y)) {\n            return { x, y };\n        }\n        else {\n            if (Math.abs(det1 - det2) < 0.1)\n                throw new Error('Segment included');\n        }\n        return null;\n    }\n    static GetCordsFromTwoPoint(pointOne, pointTwo) {\n        const sizeX = Math.abs(pointOne.x - pointTwo.x);\n        const sizeY = Math.abs(pointOne.y - pointTwo.y);\n        const lengthLine = Math.max(sizeX, sizeY);\n        const result = [pointOne];\n        function getCord(c1, c2, size, length, index) {\n            if (c2 > c1) {\n                return c1 + (index * (size / length));\n            }\n            else if (c2 < c1) {\n                return c1 - (index * (size / length));\n            }\n            return c1;\n        }\n        for (let i = 1; i <= lengthLine; i++) {\n            result.push({\n                x: getCord(pointOne.x, pointTwo.x, sizeX, lengthLine, i),\n                y: getCord(pointOne.y, pointTwo.y, sizeY, lengthLine, i)\n            });\n        }\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Helper.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/HTMLPage.ts":
/*!*****************************************!*\
  !*** ./src/StPageFlip/Page/HTMLPage.ts ***!
  \*****************************************/
/*! exports provided: HTMLPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLPage\", function() { return HTMLPage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/StPageFlip/Page/Page.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n\n\n\nclass HTMLPage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\n    constructor(render, element) {\n        super(render);\n        this.isLoad = false;\n        this.element = element;\n    }\n    draw() {\n        const pagePos = this.render.convertToGlobal(this.state.position);\n        const pageWidth = this.render.getRect().pageWidth;\n        const pageHeight = this.render.getRect().height;\n        this.element.style.display = \"block\";\n        this.element.style.transformOrigin = \"0 0\";\n        this.element.style.left = \"0\";\n        this.element.style.top = \"0\";\n        this.element.style.width = pageWidth + \"px\";\n        this.element.style.height = pageHeight + \"px\";\n        let polygon = 'polygon( ';\n        for (const p of this.state.area) {\n            if (p !== null) {\n                let g = (this.render.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_2__[\"FlipDirection\"].BACK)\n                    ? {\n                        x: -p.x + this.state.position.x,\n                        y: p.y - this.state.position.y\n                    }\n                    : {\n                        x: p.x - this.state.position.x,\n                        y: p.y - this.state.position.y\n                    };\n                g = _Helper__WEBPACK_IMPORTED_MODULE_1__[\"Helper\"].GetRotatedPoint(g, { x: 0, y: 0 }, this.state.angle);\n                polygon += g.x + 'px ' + g.y + 'px, ';\n            }\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.element.style.clipPath = polygon;\n        this.element.style.transform = \"translate(\" + pagePos.x + \"px, \" + pagePos.y + \"px) rotate(\" + this.state.angle + \"rad)\";\n    }\n    simpleDraw(orient) {\n        const rect = this.render.getRect();\n        const pageWidth = rect.pageWidth;\n        const pageHeight = rect.height;\n        const x = (orient === _Page__WEBPACK_IMPORTED_MODULE_0__[\"PageOrientation\"].Right)\n            ? rect.left + rect.pageWidth\n            : rect.left;\n        const y = rect.top;\n        this.element.style.cssText = \"display: block; height: \" + pageHeight + \"px; left: \" +\n            x + \"px; top: \" + y + \"px; width: \" + pageWidth + \"px; z-index: 2\";\n    }\n    getElement() {\n        return this.element;\n    }\n    async load() {\n        this.isLoad = true;\n        return this;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Page/HTMLPage.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/ImagePage.ts":
/*!******************************************!*\
  !*** ./src/StPageFlip/Page/ImagePage.ts ***!
  \******************************************/
/*! exports provided: ImagePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImagePage\", function() { return ImagePage; });\n/* harmony import */ var _Page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Page */ \"./src/StPageFlip/Page/Page.ts\");\n\nclass ImagePage extends _Page__WEBPACK_IMPORTED_MODULE_0__[\"Page\"] {\n    constructor(render, href) {\n        super(render);\n        this.image = null;\n        this.isLoad = false;\n        this.loadingAngle = 0;\n        this.href = href;\n    }\n    draw() {\n        const ctx = this.render.getContext();\n        const pagePos = this.render.convertToGlobal(this.state.position);\n        const pageWidth = this.render.getRect().pageWidth;\n        const pageHeight = this.render.getRect().height;\n        ctx.save();\n        ctx.translate(pagePos.x, pagePos.y);\n        ctx.beginPath();\n        for (let p of this.state.area) {\n            if (p !== null) {\n                p = this.render.convertToGlobal(p);\n                ctx.lineTo(p.x - pagePos.x, p.y - pagePos.y);\n            }\n        }\n        ctx.rotate(this.state.angle);\n        ctx.clip();\n        //ctx.imageSmoothingQuality = 'high';\n        if (!this.isLoad) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgb(200, 200, 200)';\n            ctx.fillStyle = 'rgb(255, 255, 255)';\n            ctx.lineWidth = 1;\n            ctx.rect(1, 1, pageWidth - 1, pageHeight - 1);\n            ctx.stroke();\n            ctx.fill();\n            const middlePoint = {\n                x: pageWidth / 2,\n                y: pageHeight / 2\n            };\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.arc(middlePoint.x, middlePoint.y, 20, this.loadingAngle, 3 * Math.PI / 2 + this.loadingAngle);\n            ctx.stroke();\n            ctx.closePath();\n            this.loadingAngle += 0.07;\n            if (this.loadingAngle >= 2 * Math.PI) {\n                this.loadingAngle = 0;\n            }\n        }\n        else {\n            ctx.drawImage(this.image, 0, 0, pageWidth, pageHeight);\n        }\n        ctx.restore();\n    }\n    simpleDraw(orient) {\n        const rect = this.render.getRect();\n        const ctx = this.render.getContext();\n        const pageWidth = rect.pageWidth;\n        const pageHeight = rect.height;\n        const x = (orient === _Page__WEBPACK_IMPORTED_MODULE_0__[\"PageOrientation\"].Right)\n            ? rect.left + rect.pageWidth\n            : rect.left;\n        const y = rect.top;\n        if (!this.isLoad) {\n            ctx.beginPath();\n            ctx.strokeStyle = 'rgb(200, 200, 200)';\n            ctx.fillStyle = 'rgb(255, 255, 255)';\n            ctx.lineWidth = 1;\n            ctx.rect(x + 1, y + 1, pageWidth - 1, pageHeight - 1);\n            ctx.stroke();\n            ctx.fill();\n            const middlePoint = {\n                x: x + pageWidth / 2,\n                y: y + pageHeight / 2\n            };\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.arc(middlePoint.x, middlePoint.y, 20, this.loadingAngle, 3 * Math.PI / 2 + this.loadingAngle);\n            ctx.stroke();\n            ctx.closePath();\n            this.loadingAngle += 0.07;\n            if (this.loadingAngle >= 2 * Math.PI) {\n                this.loadingAngle = 0;\n            }\n        }\n        else {\n            ctx.drawImage(this.image, x, y, pageWidth, pageHeight);\n        }\n    }\n    async load() {\n        if (this.image == null) {\n            this.image = new Image();\n            this.image.src = this.href;\n        }\n        if (this.isLoad) {\n            return Promise.resolve(this);\n        }\n        return new Promise((resolve) => {\n            this.image.onload = () => {\n                this.isLoad = true;\n                resolve(this);\n            };\n        });\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Page/ImagePage.ts?");

/***/ }),

/***/ "./src/StPageFlip/Page/Page.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/Page/Page.ts ***!
  \*************************************/
/*! exports provided: PageOrientation, Page */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PageOrientation\", function() { return PageOrientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Page\", function() { return Page; });\nvar PageOrientation;\n(function (PageOrientation) {\n    PageOrientation[PageOrientation[\"Left\"] = 0] = \"Left\";\n    PageOrientation[PageOrientation[\"Right\"] = 1] = \"Right\";\n})(PageOrientation || (PageOrientation = {}));\nclass Page {\n    constructor(render) {\n        this.state = {\n            angle: 0,\n            area: [],\n            corners: null,\n            position: { x: 0, y: 0 }\n        };\n        this.render = render;\n    }\n    setPosition(pagePos) {\n        this.state.position = pagePos;\n    }\n    setAngle(angle) {\n        this.state.angle = angle;\n    }\n    setArea(area) {\n        this.state.area = area;\n    }\n    setCorners(corners) {\n        this.state.corners = corners;\n    }\n    getAngle() {\n        return this.state.angle;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Page/Page.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/CanvasRender.ts":
/*!***********************************************!*\
  !*** ./src/StPageFlip/Render/CanvasRender.ts ***!
  \***********************************************/
/*! exports provided: CanvasRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasRender\", function() { return CanvasRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/StPageFlip/Render/Render.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n/* harmony import */ var _Page_Page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Page/Page */ \"./src/StPageFlip/Page/Page.ts\");\n\n\n\nclass CanvasRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\n    constructor(inCanvas, setting) {\n        super(setting);\n        this.canvas = inCanvas;\n        this.ctx = inCanvas.getContext('2d');\n    }\n    getBlockWidth() {\n        return this.canvas.width;\n    }\n    getBlockHeight() {\n        return this.canvas.height;\n    }\n    getContext() {\n        return this.ctx;\n    }\n    drawFrame(timer) {\n        this.clear();\n        if (this.orientation !== _Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT)\n            if (this.leftPage != null)\n                this.leftPage.simpleDraw(_Page_Page__WEBPACK_IMPORTED_MODULE_2__[\"PageOrientation\"].Left);\n        if (this.rightPage != null)\n            this.rightPage.simpleDraw(_Page_Page__WEBPACK_IMPORTED_MODULE_2__[\"PageOrientation\"].Right);\n        if (this.bottomPage != null)\n            this.bottomPage.draw();\n        this.drawBookShadow();\n        if (this.flippingPage != null)\n            this.flippingPage.draw();\n        if (this.shadow != null) {\n            this.drawOuterShadow();\n            this.drawInnerShadow();\n        }\n        const rect = this.getRect();\n        if (this.orientation === _Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT) {\n            this.ctx.beginPath();\n            this.ctx.rect(rect.left + rect.pageWidth, rect.top, rect.width, rect.height);\n            this.ctx.clip();\n        }\n    }\n    drawBookShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        const shadowSize = rect.width / 20;\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n        const shadowPos = { x: (rect.left + rect.width / 2) - shadowSize / 2, y: 0 };\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        const outerGradient = this.ctx.createLinearGradient(0, 0, shadowSize, 0);\n        outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        outerGradient.addColorStop(0.4, 'rgba(0, 0, 0, 0.2)');\n        outerGradient.addColorStop(0.49, 'rgba(0, 0, 0, 0.1)');\n        outerGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.5)');\n        outerGradient.addColorStop(0.51, 'rgba(0, 0, 0, 0.4)');\n        outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        this.ctx.clip();\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, shadowSize, rect.height * 2);\n        this.ctx.restore();\n    }\n    drawOuterShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.rect(rect.left, rect.top, rect.width, rect.height);\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n        const outerGradient = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\n        if (this.shadow.direction === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD) {\n            this.ctx.translate(0, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        }\n        else {\n            this.ctx.translate(-this.shadow.width, -100);\n            outerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n            outerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n        }\n        this.ctx.clip();\n        this.ctx.fillStyle = outerGradient;\n        this.ctx.fillRect(0, 0, this.shadow.width, rect.height * 2);\n        this.ctx.restore();\n    }\n    drawInnerShadow() {\n        const rect = this.getRect();\n        this.ctx.save();\n        this.ctx.beginPath();\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        const pageRect = this.convertRectToGlobal(this.pageRect);\n        this.ctx.moveTo(pageRect.topLeft.x, pageRect.topLeft.y);\n        this.ctx.lineTo(pageRect.topRight.x, pageRect.topRight.y);\n        this.ctx.lineTo(pageRect.bottomRight.x, pageRect.bottomRight.y);\n        this.ctx.lineTo(pageRect.bottomLeft.x, pageRect.bottomLeft.y);\n        this.ctx.translate(shadowPos.x, shadowPos.y);\n        this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n        const isw = this.shadow.width * 3 / 4;\n        const innerGradient = this.ctx.createLinearGradient(0, 0, isw, 0);\n        if (this.shadow.direction === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD) {\n            this.ctx.translate(-isw, -100);\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0.9, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.7, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n        }\n        else {\n            this.ctx.translate(0, -100);\n            innerGradient.addColorStop(0, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(0.1, 'rgba(0, 0, 0, 0.05)');\n            innerGradient.addColorStop(0.3, 'rgba(0, 0, 0, ' + (this.shadow.opacity) + ')');\n            innerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        }\n        this.ctx.clip();\n        this.ctx.fillStyle = innerGradient;\n        this.ctx.fillRect(0, 0, isw, rect.height * 2);\n        this.ctx.restore();\n    }\n    clear() {\n        this.ctx.fillStyle = 'white';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Render/CanvasRender.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/HTMLRender.ts":
/*!*********************************************!*\
  !*** ./src/StPageFlip/Render/HTMLRender.ts ***!
  \*********************************************/
/*! exports provided: HTMLRender */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLRender\", function() { return HTMLRender; });\n/* harmony import */ var _Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Render */ \"./src/StPageFlip/Render/Render.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n/* harmony import */ var _Page_Page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Page/Page */ \"./src/StPageFlip/Page/Page.ts\");\n/* harmony import */ var _Helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper */ \"./src/StPageFlip/Helper.ts\");\n\n\n\n\nclass HTMLRender extends _Render__WEBPACK_IMPORTED_MODULE_0__[\"Render\"] {\n    constructor(element, setting) {\n        super(setting);\n        this.outerShadow = null;\n        this.innerShadow = null;\n        this.element = element;\n        this.items = element.querySelectorAll('.stf__item');\n    }\n    getBlockWidth() {\n        return this.element.offsetWidth;\n    }\n    getBlockHeight() {\n        return this.element.offsetHeight;\n    }\n    clearShadow() {\n        super.clearShadow();\n        this.element.querySelector('.stf__outerShadow').remove();\n        this.element.querySelector('.stf__innerShadow').remove();\n        this.outerShadow = null;\n        this.innerShadow = null;\n    }\n    drawShadow(pos, angle, t, direction, length) {\n        super.drawShadow(pos, angle, t, direction, length);\n        if (this.outerShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__outerShadow\"></div>');\n            this.outerShadow = this.element.querySelector('.stf__outerShadow');\n        }\n        if (this.innerShadow === null) {\n            this.element.insertAdjacentHTML('beforeend', '<div class=\"stf__innerShadow\"></div>');\n            this.innerShadow = this.element.querySelector('.stf__innerShadow');\n        }\n    }\n    drawInnerShadow() {\n        const rect = this.getRect();\n        const innerShadowSize = this.shadow.width * 3 / 4;\n        const shadowTranslate = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD)\n            ? innerShadowSize\n            : 0;\n        const shadowDirection = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD)\n            ? \"to left\"\n            : \"to right\";\n        const shadowPos = this.convertToGlobal(this.shadow.pos);\n        const angle = this.shadow.angle + 3 * Math.PI / 2;\n        this.innerShadow.style.left = shadowPos.x + 'px';\n        this.innerShadow.style.top = shadowPos.y + 'px';\n        this.innerShadow.style.width = innerShadowSize + 'px';\n        this.innerShadow.style.height = rect.height * 2 + 'px';\n        this.innerShadow.style.background = \"linear-gradient(\" + shadowDirection + \", \" +\n            \"rgba(0, 0, 0, \" + this.shadow.opacity + \") 5%, \" +\n            \"rgba(0, 0, 0, 0.05) 15%,\" +\n            \"rgba(0, 0, 0, \" + this.shadow.opacity + \") 35%, \" +\n            \"rgba(0, 0, 0, 0) 100% \" +\n            \")\";\n        this.innerShadow.style.transformOrigin = shadowTranslate + \"px 100px\";\n        this.innerShadow.style.transform = \"translate(\" + (-shadowTranslate) + \"px, -100px) rotate(\" + angle + \"rad)\";\n        const clip = [this.pageRect.topLeft, this.pageRect.topRight,\n            this.pageRect.bottomRight, this.pageRect.bottomLeft];\n        let polygon = 'polygon( ';\n        for (const p of clip) {\n            let g = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].BACK)\n                ? {\n                    x: -p.x + this.shadow.pos.x,\n                    y: p.y - this.shadow.pos.y\n                }\n                : {\n                    x: p.x - this.shadow.pos.x,\n                    y: p.y - this.shadow.pos.y\n                };\n            g = _Helper__WEBPACK_IMPORTED_MODULE_3__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n            polygon += g.x + 'px ' + g.y + 'px, ';\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.innerShadow.style.clipPath = polygon;\n    }\n    drawOuterShadow() {\n        const rect = this.getRect();\n        const shadowPos = this.convertToGlobal({ x: this.shadow.pos.x, y: this.shadow.pos.y });\n        const angle = this.shadow.angle + 3 * Math.PI / 2;\n        const shadowTranslate = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].BACK)\n            ? this.shadow.width\n            : 0;\n        const shadowDirection = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD)\n            ? \"to right\"\n            : \"to left\";\n        this.outerShadow.style.left = shadowPos.x + 'px';\n        this.outerShadow.style.top = shadowPos.y + 'px';\n        this.outerShadow.style.width = this.shadow.width + 'px';\n        this.outerShadow.style.height = rect.height * 2 + 'px';\n        this.outerShadow.style.background = \"linear-gradient(\" + shadowDirection + \", rgba(0, 0, 0, \" + this.shadow.opacity + \"), rgba(0, 0, 0, 0))\";\n        this.outerShadow.style.transformOrigin = shadowTranslate + \"px 100px\"; //\n        this.outerShadow.style.transform = \"translate(\" + (-shadowTranslate) + \"px, -100px) rotate(\" + angle + \"rad)\";\n        const clip = [];\n        clip.push({ x: 0, y: 0 }, { x: rect.pageWidth, y: 0 }, { x: rect.pageWidth, y: rect.height }, { x: 0, y: rect.height });\n        let polygon = 'polygon( ';\n        for (const p of clip) {\n            if (p !== null) {\n                let g = (this.getDirection() === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].BACK)\n                    ? {\n                        x: -p.x + this.shadow.pos.x,\n                        y: p.y - this.shadow.pos.y\n                    }\n                    : {\n                        x: p.x - this.shadow.pos.x,\n                        y: p.y - this.shadow.pos.y\n                    };\n                g = _Helper__WEBPACK_IMPORTED_MODULE_3__[\"Helper\"].GetRotatedPoint(g, { x: shadowTranslate, y: 100 }, angle);\n                polygon += g.x + 'px ' + g.y + 'px, ';\n            }\n        }\n        polygon = polygon.slice(0, -2);\n        polygon += ')';\n        this.outerShadow.style.clipPath = polygon;\n    }\n    drawFrame(timer) {\n        this.clear();\n        if (this.orientation !== _Render__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"].PORTRAIT)\n            if (this.leftPage != null)\n                this.leftPage.simpleDraw(_Page_Page__WEBPACK_IMPORTED_MODULE_2__[\"PageOrientation\"].Left);\n        if (this.rightPage != null)\n            this.rightPage.simpleDraw(_Page_Page__WEBPACK_IMPORTED_MODULE_2__[\"PageOrientation\"].Right);\n        if (this.bottomPage != null) {\n            this.bottomPage.getElement().style.zIndex = \"3\";\n            this.bottomPage.draw();\n        }\n        if (this.flippingPage != null) {\n            this.flippingPage.getElement().style.zIndex = \"4\";\n            this.flippingPage.draw();\n        }\n        if (this.shadow != null) {\n            this.drawOuterShadow();\n            this.drawInnerShadow();\n        }\n    }\n    clear() {\n        for (const item of this.items) {\n            item.style.display = \"none\";\n            item.style.zIndex = \"1\";\n            item.style.transform = \"\";\n        }\n    }\n    setFlippingPage(page) {\n        super.setFlippingPage(page);\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Render/HTMLRender.ts?");

/***/ }),

/***/ "./src/StPageFlip/Render/Render.ts":
/*!*****************************************!*\
  !*** ./src/StPageFlip/Render/Render.ts ***!
  \*****************************************/
/*! exports provided: Orientation, Render */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Orientation\", function() { return Orientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Render\", function() { return Render; });\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../App */ \"./src/StPageFlip/App.ts\");\n/* harmony import */ var _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Flip/Flip */ \"./src/StPageFlip/Flip/Flip.ts\");\n\n\nvar Orientation;\n(function (Orientation) {\n    Orientation[Orientation[\"PORTRAIT\"] = 0] = \"PORTRAIT\";\n    Orientation[Orientation[\"LANDSCAPE\"] = 1] = \"LANDSCAPE\";\n})(Orientation || (Orientation = {}));\nclass Render {\n    constructor(setting) {\n        this.leftPage = null;\n        this.rightPage = null;\n        this.flippingPage = null;\n        this.bottomPage = null;\n        this.shadow = null;\n        this.pageRect = null;\n        this.animation = null;\n        this.timer = 0;\n        this.direction = null;\n        this.orientation = null;\n        this.setting = setting;\n    }\n    drawShadow(pos, angle, t, direction, length) {\n        this.shadow = {\n            pos,\n            angle,\n            width: (this.getRect().pageWidth * 3 / 4) * t / 100,\n            opacity: (100 - t) / 100,\n            direction,\n            length\n        };\n    }\n    clearShadow() {\n        this.shadow = null;\n    }\n    setPageRect(pageRect) {\n        this.pageRect = pageRect;\n    }\n    getOrientation() {\n        if (this.orientation === null)\n            this.orientation = this.findOrientation();\n        return this.orientation;\n    }\n    startAnimation(frames, duration, onAnimateEnd) {\n        this.finishAnimation();\n        this.animation = {\n            frames,\n            duration,\n            durationFrame: duration / frames.length,\n            onAnimateEnd,\n            startedAt: this.timer\n        };\n    }\n    finishAnimation() {\n        if (this.animation !== null) {\n            this.animation.frames[this.animation.frames.length - 1]();\n            if (this.animation.onAnimateEnd !== null) {\n                this.animation.onAnimateEnd();\n            }\n        }\n        this.animation = null;\n    }\n    render(timer) {\n        if (this.animation !== null) {\n            const frameIndex = Math.round((timer - this.animation.startedAt) / this.animation.durationFrame);\n            if (frameIndex < this.animation.frames.length) {\n                this.animation.frames[frameIndex]();\n            }\n            else {\n                this.animation.onAnimateEnd();\n                this.animation = null;\n            }\n        }\n        this.timer = timer;\n        this.drawFrame(timer);\n    }\n    findOrientation() {\n        return this.getBlockHeight() > this.getBlockWidth()\n            ? Orientation.PORTRAIT\n            : Orientation.LANDSCAPE;\n    }\n    getRect() {\n        const orientation = this.findOrientation();\n        const middlePoint = {\n            x: this.getBlockWidth() / 2, y: this.getBlockHeight() / 2\n        };\n        const ratio = this.setting.width / this.setting.height;\n        let pageWidth = this.setting.width;\n        let pageHeight = this.setting.height;\n        let left = middlePoint.x - pageWidth;\n        if (this.setting.size === _App__WEBPACK_IMPORTED_MODULE_0__[\"SizeType\"].STRETCH) {\n            pageWidth = (orientation === Orientation.LANDSCAPE)\n                ? this.getBlockWidth() / 2\n                : this.getBlockWidth();\n            if (pageWidth > this.setting.maxWidth)\n                pageWidth = this.setting.maxWidth;\n            pageHeight = pageWidth / ratio;\n            if (pageHeight > this.getBlockHeight()) {\n                pageHeight = this.getBlockHeight();\n                pageWidth = pageHeight * ratio;\n            }\n            left = (orientation === Orientation.LANDSCAPE)\n                ? middlePoint.x - pageWidth\n                : middlePoint.x - pageWidth / 2 - pageWidth;\n        }\n        this.orientation = orientation;\n        return {\n            left: left,\n            top: middlePoint.y - (pageHeight / 2),\n            width: pageWidth * 2,\n            height: pageHeight,\n            pageWidth: pageWidth\n        };\n    }\n    convertToBook(pos) {\n        const rect = this.getRect();\n        return {\n            x: pos.x - rect.left,\n            y: pos.y - rect.top\n        };\n    }\n    convertToPage(pos, direction) {\n        if (!direction)\n            direction = this.direction;\n        const rect = this.getRect();\n        const x = direction === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD\n            ? (pos.x - rect.left - rect.width / 2)\n            : (rect.width / 2 - pos.x + rect.left);\n        return {\n            x,\n            y: pos.y - rect.top\n        };\n    }\n    convertToGlobal(pos, direction) {\n        if (!direction)\n            direction = this.direction;\n        if (pos == null)\n            return null;\n        const rect = this.getRect();\n        const x = direction === _Flip_Flip__WEBPACK_IMPORTED_MODULE_1__[\"FlipDirection\"].FORWARD\n            ? (pos.x + rect.left + rect.width / 2)\n            : rect.width / 2 - pos.x + rect.left;\n        return {\n            x,\n            y: pos.y + rect.top\n        };\n    }\n    convertRectToGlobal(rect, direction) {\n        if (!direction)\n            direction = this.direction;\n        return {\n            topLeft: this.convertToGlobal(rect.topLeft, direction),\n            topRight: this.convertToGlobal(rect.topRight, direction),\n            bottomLeft: this.convertToGlobal(rect.bottomLeft, direction),\n            bottomRight: this.convertToGlobal(rect.bottomRight, direction)\n        };\n    }\n    start() {\n        const loop = (timer) => {\n            this.render(timer);\n            requestAnimationFrame(loop);\n        };\n        requestAnimationFrame(loop);\n    }\n    setDirection(direction) {\n        this.direction = direction;\n    }\n    getDirection() {\n        return this.direction;\n    }\n    setLeftPage(page) {\n        this.leftPage = page;\n    }\n    setFlippingPage(page) {\n        this.flippingPage = page;\n    }\n    setBottomPage(page) {\n        this.bottomPage = page;\n    }\n    setRightPage(page) {\n        this.rightPage = page;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/Render/Render.ts?");

/***/ }),

/***/ "./src/StPageFlip/UI/CanvasUI.ts":
/*!***************************************!*\
  !*** ./src/StPageFlip/UI/CanvasUI.ts ***!
  \***************************************/
/*! exports provided: CanvasUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasUI\", function() { return CanvasUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/StPageFlip/UI/UI.ts\");\n\nclass CanvasUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\n    constructor(inBlock, app, setting) {\n        super(inBlock, app, setting);\n        inBlock.innerHTML = '<canvas></canvas>';\n        this.canvas = inBlock.querySelectorAll('canvas')[0];\n        window.addEventListener('resize', () => {\n            this.resizeCanvas();\n        }, false);\n        this.distElement = this.canvas;\n        this.resizeCanvas();\n        this.setHandlers();\n    }\n    resizeCanvas() {\n        const cs = getComputedStyle(this.canvas);\n        const width = parseInt(cs.getPropertyValue('width'), 10);\n        const height = parseInt(cs.getPropertyValue('height'), 10);\n        this.canvas.width = width;\n        this.canvas.height = height;\n    }\n    getCanvas() {\n        return this.canvas;\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/UI/CanvasUI.ts?");

/***/ }),

/***/ "./src/StPageFlip/UI/HTMLUI.ts":
/*!*************************************!*\
  !*** ./src/StPageFlip/UI/HTMLUI.ts ***!
  \*************************************/
/*! exports provided: HTMLUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HTMLUI\", function() { return HTMLUI; });\n/* harmony import */ var _UI__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UI */ \"./src/StPageFlip/UI/UI.ts\");\n\nclass HTMLUI extends _UI__WEBPACK_IMPORTED_MODULE_0__[\"UI\"] {\n    constructor(inBlock, app, setting) {\n        super(inBlock, app, setting);\n        this.distElement = inBlock.querySelector('.stf__block');\n        this.setHandlers();\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/UI/HTMLUI.ts?");

/***/ }),

/***/ "./src/StPageFlip/UI/UI.ts":
/*!*********************************!*\
  !*** ./src/StPageFlip/UI/UI.ts ***!
  \*********************************/
/*! exports provided: UI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UI\", function() { return UI; });\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../App */ \"./src/StPageFlip/App.ts\");\n\nclass UI {\n    constructor(inBlock, app, setting) {\n        inBlock.classList.add('stf__wrapper');\n        inBlock.setAttribute(\"style\", \"min-width: \" + setting.minWidth * 2 +\n            'px; min-height: ' + setting.minHeight + 'px');\n        if (setting.size === _App__WEBPACK_IMPORTED_MODULE_0__[\"SizeType\"].FIXED) {\n            inBlock.setAttribute(\"style\", \"min-width: \" + setting.width * 2 +\n                'px; min-height: ' + setting.height + 'px');\n        }\n        this.app = app;\n    }\n    setHandlers() {\n        this.distElement.onmousedown = (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.startUserTouch(pos);\n            return false;\n        };\n        this.distElement.ontouchstart = (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                this.app.startUserTouch(this.getMousePos(t.clientX, t.clientY));\n            }\n            return false;\n        };\n        window.onmousemove = (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.userMove(pos);\n            return false;\n        };\n        window.ontouchmove = (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                this.app.userMove(this.getMousePos(t.clientX, t.clientY));\n            }\n        };\n        window.onmouseup = (e) => {\n            const pos = this.getMousePos(e.clientX, e.clientY);\n            this.app.userStop(pos);\n        };\n        window.ontouchend = (e) => {\n            if (e.changedTouches.length > 0) {\n                const t = e.changedTouches[0];\n                this.app.userStop(this.getMousePos(t.clientX, t.clientY));\n            }\n        };\n    }\n    getDistElement() {\n        return this.distElement;\n    }\n    getMousePos(x, y) {\n        const rect = this.distElement.getBoundingClientRect();\n        return {\n            x: x - rect.left,\n            y: y - rect.top\n        };\n    }\n}\n\n\n//# sourceURL=webpack://StPageFlip/./src/StPageFlip/UI/UI.ts?");

/***/ })

/******/ });